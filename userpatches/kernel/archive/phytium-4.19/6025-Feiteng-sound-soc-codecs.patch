From 42fe8e656302d011f8ef462be89e1d1dfcec2f3d Mon Sep 17 00:00:00 2001
From: Ricardo Pardini <ricardo@pardini.net>
Date: Thu, 4 Aug 2022 21:49:10 +0200
Subject: Feiteng sound/soc/codecs

Feiteng sound/soc/codecs
---
 sound/soc/codecs/Kconfig      |    9 +
 sound/soc/codecs/Makefile     |    4 +
 sound/soc/codecs/es8336.c     | 1093 ++++++++++
 sound/soc/codecs/es8336.h     |  161 ++
 sound/soc/codecs/es8388.c     |  819 +++++++
 sound/soc/codecs/es8388.h     |  290 +++
 sound/soc/codecs/hdmi-codec.c |   42 +
 7 files changed, 2418 insertions(+)

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index efb095dbcd71..75e8f6389967 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -606,6 +606,15 @@ config SND_SOC_ES8328_SPI
 	depends on SPI_MASTER
 	select SND_SOC_ES8328
 
+config SND_SOC_ES8336
+	tristate "Everest Semi ES8336 CODEC"
+	depends on I2C
+	select GPIO_PHYTIUM_PCI
+
+config SND_SOC_ES8388
+	tristate "Everest Semi ES8388 CODEC"
+	depends on I2C
+
 config SND_SOC_GTM601
 	tristate 'GTM601 UMTS modem audio codec'
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 7ae7c85e8219..1ba362d2dd65 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -76,6 +76,8 @@ snd-soc-es8316-objs := es8316.o
 snd-soc-es8328-objs := es8328.o
 snd-soc-es8328-i2c-objs := es8328-i2c.o
 snd-soc-es8328-spi-objs := es8328-spi.o
+snd-soc-es8336-objs := es8336.o
+snd-soc-es8388-objs := es8388.o
 snd-soc-gtm601-objs := gtm601.o
 snd-soc-hdac-hdmi-objs := hdac_hdmi.o
 snd-soc-ics43432-objs := ics43432.o
@@ -336,6 +338,8 @@ obj-$(CONFIG_SND_SOC_ES8316)    += snd-soc-es8316.o
 obj-$(CONFIG_SND_SOC_ES8328)	+= snd-soc-es8328.o
 obj-$(CONFIG_SND_SOC_ES8328_I2C)+= snd-soc-es8328-i2c.o
 obj-$(CONFIG_SND_SOC_ES8328_SPI)+= snd-soc-es8328-spi.o
+obj-$(CONFIG_SND_SOC_ES8336)+= snd-soc-es8336.o
+obj-$(CONFIG_SND_SOC_ES8388)	+= snd-soc-es8388.o
 obj-$(CONFIG_SND_SOC_GTM601)    += snd-soc-gtm601.o
 obj-$(CONFIG_SND_SOC_HDAC_HDMI) += snd-soc-hdac-hdmi.o
 obj-$(CONFIG_SND_SOC_ICS43432)	+= snd-soc-ics43432.o
diff --git a/sound/soc/codecs/es8336.c b/sound/soc/codecs/es8336.c
new file mode 100644
index 000000000000..c381f4fc4df4
--- /dev/null
+++ b/sound/soc/codecs/es8336.c
@@ -0,0 +1,1093 @@
+/*
+ * es8336.c -- es8336 ALSA SoC audio driver
+ * Copyright Everest Semiconductor Co.,Ltd
+ *           Phytium Information Technology Co.,Ltd
+ *
+ * Author: David Yang <yangxiaohua@everest-semi.com>
+ *         Yiqun Zhang <zhangyiqun@phytium.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of_gpio.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <linux/proc_fs.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/regmap.h>
+#include "es8336.h"
+
+#define INVALID_GPIO -1
+#define GPIO_LOW  0
+#define GPIO_HIGH 1
+
+static struct snd_soc_component *es8336_component;
+
+static const struct reg_default es8336_reg_defaults[] = {
+	{0x00, 0x03}, {0x01, 0x03}, {0x02, 0x00}, {0x03, 0x20},
+	{0x04, 0x11}, {0x05, 0x00}, {0x06, 0x11}, {0x07, 0x00},
+	{0x08, 0x00}, {0x09, 0x01}, {0x0a, 0x00}, {0x0b, 0x00},
+	{0x0c, 0xf8}, {0x0d, 0x3f}, {0x0e, 0x00}, {0x0f, 0x00},
+	{0x10, 0x01}, {0x11, 0xfc}, {0x12, 0x28}, {0x13, 0x00},
+	{0x14, 0x00}, {0x15, 0x33}, {0x16, 0x00}, {0x17, 0x00},
+	{0x18, 0x88}, {0x19, 0x06}, {0x1a, 0x22}, {0x1b, 0x03},
+	{0x1c, 0x0f}, {0x1d, 0x00}, {0x1e, 0x80}, {0x1f, 0x80},
+	{0x20, 0x00}, {0x21, 0x00}, {0x22, 0xc0}, {0x23, 0x00},
+	{0x24, 0x01}, {0x25, 0x08}, {0x26, 0x10}, {0x27, 0xc0},
+	{0x28, 0x00}, {0x29, 0x1c}, {0x2a, 0x00}, {0x2b, 0xb0},
+	{0x2c, 0x32}, {0x2d, 0x03}, {0x2e, 0x00}, {0x2f, 0x11},
+	{0x30, 0x10}, {0x31, 0x00}, {0x32, 0x00}, {0x33, 0xc0},
+	{0x34, 0xc0}, {0x35, 0x1f}, {0x36, 0xf7}, {0x37, 0xfd},
+	{0x38, 0xff}, {0x39, 0x1f}, {0x3a, 0xf7}, {0x3b, 0xfd},
+	{0x3c, 0xff}, {0x3d, 0x1f}, {0x3e, 0xf7}, {0x3f, 0xfd},
+	{0x40, 0xff}, {0x41, 0x1f}, {0x42, 0xf7}, {0x43, 0xfd},
+	{0x44, 0xff}, {0x45, 0x1f}, {0x46, 0xf7}, {0x47, 0xfd},
+	{0x48, 0xff}, {0x49, 0x1f}, {0x4a, 0xf7}, {0x4b, 0xfd},
+	{0x4c, 0xff}, {0x4d, 0x00}, {0x4e, 0x00}, {0x4f, 0xff},
+	{0x50, 0x00}, {0x51, 0x00}, {0x52, 0x00}, {0x53, 0x00},
+};
+
+/* codec private data */
+struct es8336_priv {
+	struct regmap *regmap;
+	unsigned int dmic_amic;
+	unsigned int sysclk;
+	struct snd_pcm_hw_constraint_list *sysclk_constraints;
+	struct clk *mclk;
+	int debounce_time;
+	int hp_det_invert;
+	struct delayed_work work;
+
+	int spk_ctl_gpio;
+	int hp_det_gpio;
+	bool muted;
+	bool hp_inserted;
+	bool spk_active_level;
+
+	int pwr_count;
+};
+
+/*
+ * es8336_reset
+ * write value 0xff to reg0x00, the chip will be in reset mode
+ * then, writer 0x00 to reg0x00, unreset the chip
+ */
+static int es8336_reset(struct snd_soc_component *component)
+{
+	snd_soc_component_write(component, ES8336_RESET_REG00, 0x3F);
+	usleep_range(5000, 5500);
+	return snd_soc_component_write(component, ES8336_RESET_REG00, 0x03);
+}
+
+static void es8336_enable_spk(struct es8336_priv *es8336, bool enable)
+{
+	bool level;
+
+	level = enable ? es8336->spk_active_level : !es8336->spk_active_level;
+	gpio_set_value(es8336->spk_ctl_gpio, level);
+}
+
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -9600, 50, 1);
+static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -9600, 50, 1);
+static const DECLARE_TLV_DB_SCALE(hpmixer_gain_tlv, -1200, 150, 0);
+static const DECLARE_TLV_DB_SCALE(mic_bst_tlv, 0, 1200, 0);
+
+static unsigned int linin_pga_tlv[] = {
+	TLV_DB_RANGE_HEAD(9),
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	1, 1, TLV_DB_SCALE_ITEM(300, 0, 0),
+	2, 2, TLV_DB_SCALE_ITEM(600, 0, 0),
+	3, 3, TLV_DB_SCALE_ITEM(900, 0, 0),
+	4, 4, TLV_DB_SCALE_ITEM(1200, 0, 0),
+	5, 5, TLV_DB_SCALE_ITEM(1500, 0, 0),
+	6, 6, TLV_DB_SCALE_ITEM(1800, 0, 0),
+	7, 7, TLV_DB_SCALE_ITEM(2100, 0, 0),
+	8, 8, TLV_DB_SCALE_ITEM(2400, 0, 0),
+};
+
+static unsigned int hpout_vol_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 3, TLV_DB_SCALE_ITEM(-4800, 1200, 0),
+};
+
+static const char *const alc_func_txt[] = { "Off", "On" };
+
+static const struct soc_enum alc_func =
+	SOC_ENUM_SINGLE(ES8336_ADC_ALC1_REG29, 6, 2, alc_func_txt);
+
+static const char *const ng_type_txt[] = {
+	"Constant PGA Gain", "Mute ADC Output" };
+
+static const struct soc_enum ng_type =
+	SOC_ENUM_SINGLE(ES8336_ADC_ALC6_REG2E, 6, 2, ng_type_txt);
+
+static const char *const adcpol_txt[] = { "Normal", "Invert" };
+
+static const struct soc_enum adcpol =
+	SOC_ENUM_SINGLE(ES8336_ADC_MUTE_REG26, 1, 2, adcpol_txt);
+
+static const char *const dacpol_txt[] = {
+	"Normal", "R Invert", "L Invert", "L + R Invert" };
+
+static const struct soc_enum dacpol =
+	SOC_ENUM_SINGLE(ES8336_DAC_SET1_REG30, 0, 4, dacpol_txt);
+
+static const struct snd_kcontrol_new es8336_snd_controls[] = {
+	/* HP OUT VOLUME */
+	SOC_DOUBLE_TLV("HP Playback Volume", ES8336_CPHP_ICAL_VOL_REG18,
+		       4, 0, 4, 1, hpout_vol_tlv),
+	/* HPMIXER VOLUME Control */
+	SOC_DOUBLE_TLV("HPMixer Gain", ES8336_HPMIX_VOL_REG16,
+		       0, 4, 7, 0, hpmixer_gain_tlv),
+
+	/* DAC Digital controls */
+	SOC_DOUBLE_R_TLV("DAC Playback Volume", ES8336_DAC_VOLL_REG33,
+			 ES8336_DAC_VOLR_REG34, 0, 0xC0, 1, dac_vol_tlv),
+
+	SOC_SINGLE("Enable DAC Soft Ramp", ES8336_DAC_SET1_REG30, 4, 1, 1),
+	SOC_SINGLE("DAC Soft Ramp Rate", ES8336_DAC_SET1_REG30, 2, 4, 0),
+
+	SOC_ENUM("Playback Polarity", dacpol),
+	SOC_SINGLE("DAC Notch Filter", ES8336_DAC_SET2_REG31, 6, 1, 0),
+	SOC_SINGLE("DAC Double Fs Mode", ES8336_DAC_SET2_REG31, 7, 1, 0),
+	SOC_SINGLE("DAC Volume Control-LeR", ES8336_DAC_SET2_REG31, 2, 1, 0),
+	SOC_SINGLE("DAC Stereo Enhancement", ES8336_DAC_SET3_REG32, 0, 7, 0),
+
+	/* +20dB D2SE PGA Control */
+	SOC_SINGLE_TLV("MIC Boost", ES8336_ADC_D2SEPGA_REG24,
+		       0, 1, 0, mic_bst_tlv),
+	/* 0-+24dB Lineinput PGA Control */
+	SOC_SINGLE_TLV("Input PGA", ES8336_ADC_PGAGAIN_REG23,
+		       4, 8, 0, linin_pga_tlv),
+};
+
+/* Analog Input MUX */
+static const char * const es8336_analog_in_txt[] = {
+	"lin1-rin1",
+	"lin2-rin2",
+	"lin1-rin1 with 20db Boost",
+	"lin2-rin2 with 20db Boost"
+};
+
+static const unsigned int es8336_analog_in_values[] = { 0, 1, 2, 3 };
+
+static const struct soc_enum es8336_analog_input_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8336_ADC_PDN_LINSEL_REG22, 4, 3,
+			      ARRAY_SIZE(es8336_analog_in_txt),
+			      es8336_analog_in_txt,
+			      es8336_analog_in_values);
+
+static const struct snd_kcontrol_new es8336_analog_in_mux_controls =
+	SOC_DAPM_ENUM("Route", es8336_analog_input_enum);
+
+/* Dmic MUX */
+static const char * const es8336_dmic_txt[] = {
+	"dmic disable",
+	"dmic data at high level",
+	"dmic data at low level",
+};
+
+static const unsigned int es8336_dmic_values[] = { 0, 2, 3 };
+
+static const struct soc_enum es8336_dmic_src_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8336_ADC_DMIC_REG25, 0, 3,
+			      ARRAY_SIZE(es8336_dmic_txt),
+			      es8336_dmic_txt,
+			      es8336_dmic_values);
+
+static const struct snd_kcontrol_new es8336_dmic_src_controls =
+	SOC_DAPM_ENUM("Route", es8336_dmic_src_enum);
+
+/* hp mixer mux */
+static const char *const es8336_hpmux_texts[] = {
+	"lin1-rin1",
+	"lin2-rin2",
+	"lin-rin with Boost",
+	"lin-rin with Boost and PGA"
+};
+
+static const unsigned int es8336_hpmux_values[] = { 0, 1, 2, 3 };
+
+static const struct soc_enum es8336_left_hpmux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8336_HPMIX_SEL_REG13, 4, 7,
+			      ARRAY_SIZE(es8336_hpmux_texts),
+			      es8336_hpmux_texts,
+			      es8336_hpmux_values);
+
+static const struct snd_kcontrol_new es8336_left_hpmux_controls =
+	SOC_DAPM_ENUM("Route", es8336_left_hpmux_enum);
+
+static const struct soc_enum es8336_right_hpmux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8336_HPMIX_SEL_REG13, 0, 7,
+			      ARRAY_SIZE(es8336_hpmux_texts),
+			      es8336_hpmux_texts,
+			      es8336_hpmux_values);
+
+static const struct snd_kcontrol_new es8336_right_hpmux_controls =
+	SOC_DAPM_ENUM("Route", es8336_right_hpmux_enum);
+
+/* headphone Output Mixer */
+static const struct snd_kcontrol_new es8336_out_left_mix[] = {
+	SOC_DAPM_SINGLE("LLIN Switch", ES8336_HPMIX_SWITCH_REG14,
+			6, 1, 0),
+	SOC_DAPM_SINGLE("Left DAC Switch", ES8336_HPMIX_SWITCH_REG14,
+			7, 1, 0),
+};
+
+static const struct snd_kcontrol_new es8336_out_right_mix[] = {
+	SOC_DAPM_SINGLE("RLIN Switch", ES8336_HPMIX_SWITCH_REG14,
+			2, 1, 0),
+	SOC_DAPM_SINGLE("Right DAC Switch", ES8336_HPMIX_SWITCH_REG14,
+			3, 1, 0),
+};
+
+/* DAC data source mux */
+static const char * const es8336_dacsrc_texts[] = {
+	"LDATA TO LDAC, RDATA TO RDAC",
+	"LDATA TO LDAC, LDATA TO RDAC",
+	"RDATA TO LDAC, RDATA TO RDAC",
+	"RDATA TO LDAC, LDATA TO RDAC",
+};
+
+static const unsigned int es8336_dacsrc_values[] = { 0, 1, 2, 3 };
+
+static const struct soc_enum es8336_dacsrc_mux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8336_DAC_SET1_REG30, 6, 4,
+			      ARRAY_SIZE(es8336_dacsrc_texts),
+			      es8336_dacsrc_texts,
+			      es8336_dacsrc_values);
+static const struct snd_kcontrol_new es8336_dacsrc_mux_controls =
+	SOC_DAPM_ENUM("Route", es8336_dacsrc_mux_enum);
+
+static const struct snd_soc_dapm_widget es8336_dapm_widgets[] = {
+	/* Input Lines */
+	SND_SOC_DAPM_INPUT("DMIC"),
+	SND_SOC_DAPM_INPUT("MIC1"),
+	SND_SOC_DAPM_INPUT("MIC2"),
+
+	SND_SOC_DAPM_MICBIAS("micbias", SND_SOC_NOPM,
+			     0, 0),
+	/* Input MUX */
+	SND_SOC_DAPM_MUX("Differential Mux", SND_SOC_NOPM, 0, 0,
+			 &es8336_analog_in_mux_controls),
+
+	SND_SOC_DAPM_PGA("Line input PGA", ES8336_ADC_PDN_LINSEL_REG22,
+			 7, 1, NULL, 0),
+
+	/* ADCs */
+	SND_SOC_DAPM_ADC("Mono ADC", NULL, ES8336_ADC_PDN_LINSEL_REG22, 6, 1),
+
+	/* Dmic MUX */
+	SND_SOC_DAPM_MUX("Digital Mic Mux", SND_SOC_NOPM, 0, 0,
+			 &es8336_dmic_src_controls),
+
+	/* Digital Interface */
+	SND_SOC_DAPM_AIF_OUT("I2S OUT", "I2S1 Capture",  1,
+			     ES8336_SDP_ADCFMT_REG0A, 6, 1),
+
+	SND_SOC_DAPM_AIF_IN("I2S IN", "I2S1 Playback", 0,
+			    SND_SOC_NOPM, 0, 0),
+
+	/*  DACs DATA SRC MUX */
+	SND_SOC_DAPM_MUX("DAC SRC Mux", SND_SOC_NOPM, 0, 0,
+			 &es8336_dacsrc_mux_controls),
+	/*  DACs  */
+	SND_SOC_DAPM_DAC("Right DAC", NULL, ES8336_DAC_PDN_REG2F, 0, 1),
+	SND_SOC_DAPM_DAC("Left DAC", NULL, ES8336_DAC_PDN_REG2F, 4, 1),
+
+	/* Headphone Output Side */
+	/* hpmux for hp mixer */
+	SND_SOC_DAPM_MUX("Left Hp mux", SND_SOC_NOPM, 0, 0,
+			 &es8336_left_hpmux_controls),
+	SND_SOC_DAPM_MUX("Right Hp mux", SND_SOC_NOPM, 0, 0,
+			 &es8336_right_hpmux_controls),
+	/* Output mixer  */
+	SND_SOC_DAPM_MIXER("Left Hp mixer", ES8336_HPMIX_PDN_REG15,
+			   4, 1, &es8336_out_left_mix[0],
+			   ARRAY_SIZE(es8336_out_left_mix)),
+	SND_SOC_DAPM_MIXER("Right Hp mixer", ES8336_HPMIX_PDN_REG15,
+			   0, 1, &es8336_out_right_mix[0],
+			   ARRAY_SIZE(es8336_out_right_mix)),
+	SND_SOC_DAPM_MIXER("Left Hp mixer", SND_SOC_NOPM,
+			   4, 1, &es8336_out_left_mix[0],
+			   ARRAY_SIZE(es8336_out_left_mix)),
+	SND_SOC_DAPM_MIXER("Right Hp mixer", SND_SOC_NOPM,
+			   0, 1, &es8336_out_right_mix[0],
+			   ARRAY_SIZE(es8336_out_right_mix)),
+
+	/* Output charge pump */
+	SND_SOC_DAPM_PGA("HPCP L", ES8336_CPHP_OUTEN_REG17,
+			 6, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("HPCP R", ES8336_CPHP_OUTEN_REG17,
+			 2, 0, NULL, 0),
+
+	/* Output Driver */
+	SND_SOC_DAPM_PGA("HPVOL L", ES8336_CPHP_OUTEN_REG17,
+			 5, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("HPVOL R", ES8336_CPHP_OUTEN_REG17,
+			 1, 0, NULL, 0),
+	/* Output Lines */
+	SND_SOC_DAPM_OUTPUT("HPOL"),
+	SND_SOC_DAPM_OUTPUT("HPOR"),
+};
+
+static const struct snd_soc_dapm_route es8336_dapm_routes[] = {
+	/*
+	 * record route map
+	 */
+	{"MIC1", NULL, "micbias"},
+	{"MIC2", NULL, "micbias"},
+	{"DMIC", NULL, "micbias"},
+
+	{"Differential Mux", "lin1-rin1", "MIC1"},
+	{"Differential Mux", "lin2-rin2", "MIC2"},
+	{"Differential Mux", "lin1-rin1 with 20db Boost", "MIC1"},
+	{"Differential Mux", "lin2-rin2 with 20db Boost", "MIC2"},
+	{"Line input PGA", NULL, "Differential Mux"},
+
+	{"Mono ADC", NULL, "Line input PGA"},
+
+	{"Digital Mic Mux", "dmic disable", "Mono ADC"},
+	{"Digital Mic Mux", "dmic data at high level", "DMIC"},
+	{"Digital Mic Mux", "dmic data at low level", "DMIC"},
+
+	{"I2S OUT", NULL, "Digital Mic Mux"},
+	/*
+	 * playback route map
+	 */
+	{"DAC SRC Mux", "LDATA TO LDAC, RDATA TO RDAC", "I2S IN"},
+	{"DAC SRC Mux", "LDATA TO LDAC, LDATA TO RDAC", "I2S IN"},
+	{"DAC SRC Mux", "RDATA TO LDAC, RDATA TO RDAC", "I2S IN"},
+	{"DAC SRC Mux", "RDATA TO LDAC, LDATA TO RDAC", "I2S IN"},
+
+	{"Left DAC", NULL, "DAC SRC Mux"},
+	{"Right DAC", NULL, "DAC SRC Mux"},
+
+	{"Left Hp mux", "lin1-rin1", "MIC1"},
+	{"Left Hp mux", "lin2-rin2", "MIC2"},
+	{"Left Hp mux", "lin-rin with Boost", "Differential Mux"},
+	{"Left Hp mux", "lin-rin with Boost and PGA", "Line input PGA"},
+
+	{"Right Hp mux", "lin1-rin1", "MIC1"},
+	{"Right Hp mux", "lin2-rin2", "MIC2"},
+	{"Right Hp mux", "lin-rin with Boost", "Differential Mux"},
+	{"Right Hp mux", "lin-rin with Boost and PGA", "Line input PGA"},
+
+	{"Left Hp mixer", "LLIN Switch", "Left Hp mux"},
+	{"Left Hp mixer", "Left DAC Switch", "Left DAC"},
+
+	{"Right Hp mixer", "RLIN Switch", "Right Hp mux"},
+	{"Right Hp mixer", "Right DAC Switch", "Right DAC"},
+
+	{"HPCP L", NULL, "Left Hp mixer"},
+	{"HPCP R", NULL, "Right Hp mixer"},
+
+	{"HPVOL L", NULL, "HPCP L"},
+	{"HPVOL R", NULL, "HPCP R"},
+
+	{"HPOL", NULL, "HPVOL L"},
+	{"HPOR", NULL, "HPVOL R"},
+};
+
+
+/* The set of rates we can generate from the above for each SYSCLK */
+
+static unsigned int rates_12288[] = {
+	8000, 12000, 16000, 24000, 24000, 32000, 48000, 96000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_12288 = {
+	.count	= ARRAY_SIZE(rates_12288),
+	.list	= rates_12288,
+};
+
+static unsigned int rates_112896[] = {
+	8000, 11025, 22050, 44100,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_112896 = {
+	.count	= ARRAY_SIZE(rates_112896),
+	.list	= rates_112896,
+};
+
+static unsigned int rates_12[] = {
+	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,
+	48000, 88235, 96000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_12 = {
+	.count	= ARRAY_SIZE(rates_12),
+	.list	= rates_12,
+};
+
+/*
+ * Note that this should be called from init rather than from hw_params.
+ */
+static int es8336_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				 int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	struct es8336_priv *es8336 = snd_soc_component_get_drvdata(component);
+
+	switch (freq) {
+	case 11289600:
+	case 18432000:
+	case 22579200:
+	case 36864000:
+		es8336->sysclk_constraints = &constraints_112896;
+		es8336->sysclk = freq;
+		return 0;
+	case 12288000:
+	case 19200000:
+	case 16934400:
+	case 24576000:
+	case 33868800:
+		es8336->sysclk_constraints = &constraints_12288;
+		es8336->sysclk = freq;
+		return 0;
+	case 12000000:
+	case 24000000:
+		es8336->sysclk_constraints = &constraints_12;
+		es8336->sysclk = freq;
+		return 0;
+	}
+
+	return 0;
+}
+
+static int es8336_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			      unsigned int fmt)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	u8 iface = 0;
+	u8 adciface = 0;
+	u8 daciface = 0;
+
+	iface    = snd_soc_component_read32(component, ES8336_IFACE);
+	adciface = snd_soc_component_read32(component, ES8336_ADC_IFACE);
+	daciface = snd_soc_component_read32(component, ES8336_DAC_IFACE);
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface |= 0x80;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		iface &= 0x7F;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		adciface &= 0xFC;
+		daciface &= 0xFC;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		return -EINVAL;
+	case SND_SOC_DAIFMT_LEFT_J:
+		adciface &= 0xFC;
+		daciface &= 0xFC;
+		adciface |= 0x01;
+		daciface |= 0x01;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		adciface &= 0xDC;
+		daciface &= 0xDC;
+		adciface |= 0x03;
+		daciface |= 0x03;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		adciface &= 0xDC;
+		daciface &= 0xDC;
+		adciface |= 0x23;
+		daciface |= 0x23;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		iface    &= 0xDF;
+		adciface &= 0xDF;
+		daciface &= 0xDF;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface    |= 0x20;
+		adciface |= 0x20;
+		daciface |= 0x20;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface    |= 0x20;
+		adciface &= 0xDF;
+		daciface &= 0xDF;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface    &= 0xDF;
+		adciface |= 0x20;
+		daciface |= 0x20;
+		break;
+	default:
+		return -EINVAL;
+	}
+	snd_soc_component_write(component, ES8336_IFACE, iface);
+	snd_soc_component_write(component, ES8336_ADC_IFACE, adciface);
+	snd_soc_component_write(component, ES8336_DAC_IFACE, daciface);
+	return 0;
+}
+
+static int es8336_pcm_startup(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct es8336_priv *es8336 = snd_soc_component_get_drvdata(component);
+	bool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+
+	snd_soc_component_write(component, ES8336_RESET_REG00, 0xC0);
+	snd_soc_component_write(component, ES8336_SYS_PDN_REG0D, 0x00);
+	/* es8336: both playback and capture need dac mclk */
+	snd_soc_component_update_bits(component, ES8336_CLKMGR_CLKSW_REG01,
+			    ES8336_CLKMGR_MCLK_DIV_MASK |
+			    ES8336_CLKMGR_DAC_MCLK_MASK,
+			    ES8336_CLKMGR_MCLK_DIV_NML |
+			    ES8336_CLKMGR_DAC_MCLK_EN);
+	es8336->pwr_count++;
+
+	if (playback) {
+		snd_soc_component_write(component, ES8336_SYS_LP1_REG0E, 0x3F);
+		snd_soc_component_write(component, ES8336_SYS_LP2_REG0F, 0x1F);
+		snd_soc_component_write(component, ES8336_HPMIX_SWITCH_REG14, 0x88);
+		snd_soc_component_write(component, ES8336_HPMIX_PDN_REG15, 0x00);
+		snd_soc_component_write(component, ES8336_HPMIX_VOL_REG16, 0xBB);
+		snd_soc_component_write(component, ES8336_CPHP_PDN2_REG1A, 0x10);
+		snd_soc_component_write(component, ES8336_CPHP_LDOCTL_REG1B, 0x30);
+		snd_soc_component_write(component, ES8336_CPHP_PDN1_REG19, 0x02);
+		snd_soc_component_write(component, ES8336_DAC_PDN_REG2F, 0x00);
+		snd_soc_component_write(component, ES8336_CPHP_OUTEN_REG17, 0x66);
+		snd_soc_component_update_bits(component, ES8336_CLKMGR_CLKSW_REG01,
+				    ES8336_CLKMGR_DAC_MCLK_MASK |
+				    ES8336_CLKMGR_DAC_ANALOG_MASK,
+				    ES8336_CLKMGR_DAC_MCLK_EN |
+				    ES8336_CLKMGR_DAC_ANALOG_EN);
+		msleep(50);
+	} else {
+		snd_soc_component_update_bits(component,
+				    ES8336_ADC_PDN_LINSEL_REG22, 0xC0, 0x20);
+		snd_soc_component_update_bits(component, ES8336_CLKMGR_CLKSW_REG01,
+				    ES8336_CLKMGR_ADC_MCLK_MASK |
+				    ES8336_CLKMGR_ADC_ANALOG_MASK,
+				    ES8336_CLKMGR_ADC_MCLK_EN |
+				    ES8336_CLKMGR_ADC_ANALOG_EN);
+	}
+
+	return 0;
+}
+
+static void es8336_pcm_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct es8336_priv *es8336 = snd_soc_component_get_drvdata(component);
+	bool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+
+	if (playback) {
+		snd_soc_component_write(component, ES8336_CPHP_OUTEN_REG17, 0x00);
+		snd_soc_component_write(component, ES8336_DAC_PDN_REG2F, 0x11);
+		snd_soc_component_write(component, ES8336_CPHP_LDOCTL_REG1B, 0x03);
+		snd_soc_component_write(component, ES8336_CPHP_PDN2_REG1A, 0x22);
+		snd_soc_component_write(component, ES8336_CPHP_PDN1_REG19, 0x06);
+		snd_soc_component_write(component, ES8336_HPMIX_SWITCH_REG14, 0x00);
+		snd_soc_component_write(component, ES8336_HPMIX_PDN_REG15, 0x33);
+		snd_soc_component_write(component, ES8336_HPMIX_VOL_REG16, 0x00);
+		snd_soc_component_write(component, ES8336_SYS_PDN_REG0D, 0x00);
+		snd_soc_component_write(component, ES8336_SYS_LP1_REG0E, 0xFF);
+		snd_soc_component_write(component, ES8336_SYS_LP2_REG0F, 0xFF);
+		snd_soc_component_update_bits(component, ES8336_CLKMGR_CLKSW_REG01,
+				    ES8336_CLKMGR_DAC_ANALOG_MASK,
+				    ES8336_CLKMGR_DAC_ANALOG_DIS);
+	} else {
+		snd_soc_component_write(component, ES8336_ADC_PDN_LINSEL_REG22, 0xc0);
+		snd_soc_component_update_bits(component, ES8336_CLKMGR_CLKSW_REG01,
+				    ES8336_CLKMGR_ADC_MCLK_MASK |
+				    ES8336_CLKMGR_ADC_ANALOG_MASK,
+				    ES8336_CLKMGR_ADC_MCLK_DIS |
+				    ES8336_CLKMGR_ADC_ANALOG_DIS);
+	}
+
+	if (--es8336->pwr_count == 0) {
+		if (!es8336->hp_inserted)
+			snd_soc_component_write(component, ES8336_SYS_PDN_REG0D, 0x3F);
+		snd_soc_component_write(component, ES8336_CLKMGR_CLKSW_REG01, 0xF3);
+	}
+}
+
+
+static int es8336_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	int val = 0;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		val = ES8336_DACWL_16;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		val = ES8336_DACWL_20;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		val = ES8336_DACWL_24;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		val = ES8336_DACWL_32;
+		break;
+	default:
+		val = ES8336_DACWL_16;
+		break;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_component_update_bits(component, ES8336_SDP_DACFMT_REG0B,
+				    ES8336_DACWL_MASK, val);
+	else
+		snd_soc_component_update_bits(component, ES8336_SDP_ADCFMT_REG0A,
+				    ES8336_ADCWL_MASK, val);
+
+	return 0;
+}
+
+static int es8336_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_component *component = dai->component;
+	struct es8336_priv *es8336 = snd_soc_component_get_drvdata(component);
+
+	es8336->muted = mute;
+	if (mute) {
+		es8336_enable_spk(es8336, false);
+		msleep(100);
+		snd_soc_component_write(component, ES8336_DAC_SET1_REG30, 0x20);
+	} else if (dai->playback_active) {
+		snd_soc_component_write(component, ES8336_DAC_SET1_REG30, 0x00);
+		msleep(130);
+		if (!es8336->hp_inserted)
+			es8336_enable_spk(es8336, true);
+	}
+	return 0;
+}
+
+static int es8336_set_bias_level(struct snd_soc_component *component,
+				 enum snd_soc_bias_level level)
+{
+	struct es8336_priv *es8336 = snd_soc_component_get_drvdata(component);
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		snd_soc_component_write(component, ES8336_CPHP_OUTEN_REG17, 0x00);
+		snd_soc_component_write(component, ES8336_DAC_PDN_REG2F, 0x11);
+		snd_soc_component_write(component, ES8336_CPHP_LDOCTL_REG1B, 0x03);
+		snd_soc_component_write(component, ES8336_CPHP_PDN2_REG1A, 0x22);
+		snd_soc_component_write(component, ES8336_CPHP_PDN1_REG19, 0x06);
+		snd_soc_component_write(component, ES8336_HPMIX_SWITCH_REG14, 0x00);
+		snd_soc_component_write(component, ES8336_HPMIX_PDN_REG15, 0x33);
+		snd_soc_component_write(component, ES8336_HPMIX_VOL_REG16, 0x00);
+		snd_soc_component_write(component, ES8336_ADC_PDN_LINSEL_REG22, 0xC0);
+		if (!es8336->hp_inserted)
+			snd_soc_component_write(component, ES8336_SYS_PDN_REG0D, 0x3F);
+		snd_soc_component_write(component, ES8336_SYS_LP1_REG0E, 0x3F);
+		snd_soc_component_write(component, ES8336_SYS_LP2_REG0F, 0x1F);
+		snd_soc_component_write(component, ES8336_RESET_REG00, 0x00);
+		break;
+	}
+
+	return 0;
+}
+
+#define es8336_RATES SNDRV_PCM_RATE_8000_96000
+
+#define es8336_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+static const struct snd_soc_dai_ops es8336_ops = {
+	.startup = es8336_pcm_startup,
+	.hw_params = es8336_pcm_hw_params,
+	.set_fmt = es8336_set_dai_fmt,
+	.set_sysclk = es8336_set_dai_sysclk,
+	.digital_mute = es8336_mute,
+	.shutdown = es8336_pcm_shutdown,
+};
+
+static struct snd_soc_dai_driver es8336_dai = {
+	.name = "es8336-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = es8336_RATES,
+		.formats = es8336_FORMATS,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = es8336_RATES,
+		.formats = es8336_FORMATS,
+	},
+	.ops = &es8336_ops,
+	.symmetric_rates = 1,
+};
+
+static int es8336_init_regs(struct snd_soc_component *component)
+{
+	snd_soc_component_write(component, ES8336_RESET_REG00, 0x3f);
+	usleep_range(5000, 5500);
+	snd_soc_component_write(component, ES8336_RESET_REG00, 0x00);
+	snd_soc_component_write(component, ES8336_SYS_VMIDSEL_REG0C, 0xFF);
+	msleep(30);
+	snd_soc_component_write(component, ES8336_CLKMGR_CLKSEL_REG02, 0x08);
+	snd_soc_component_write(component, ES8336_CLKMGR_ADCOSR_REG03, 0x20);
+	snd_soc_component_write(component, ES8336_CLKMGR_ADCDIV1_REG04, 0x11);
+	snd_soc_component_write(component, ES8336_CLKMGR_ADCDIV2_REG05, 0x00);
+	snd_soc_component_write(component, ES8336_CLKMGR_DACDIV1_REG06, 0x11);
+	snd_soc_component_write(component, ES8336_CLKMGR_DACDIV2_REG07, 0x00);
+	snd_soc_component_write(component, ES8336_CLKMGR_CPDIV_REG08, 0x00);
+	snd_soc_component_write(component, ES8336_SDP_MS_BCKDIV_REG09, 0x04);
+	snd_soc_component_write(component, ES8336_CLKMGR_CLKSW_REG01, 0x7F);
+	snd_soc_component_write(component, ES8336_CAL_TYPE_REG1C, 0x0F);
+	snd_soc_component_write(component, ES8336_CAL_HPLIV_REG1E, 0x90);
+	snd_soc_component_write(component, ES8336_CAL_HPRIV_REG1F, 0x90);
+	snd_soc_component_write(component, ES8336_ADC_VOLUME_REG27, 0x00);
+	snd_soc_component_write(component, ES8336_ADC_PDN_LINSEL_REG22, 0xc0);
+	snd_soc_component_write(component, ES8336_ADC_D2SEPGA_REG24, 0x00);
+	snd_soc_component_write(component, ES8336_ADC_DMIC_REG25, 0x08);
+	snd_soc_component_write(component, ES8336_DAC_SET2_REG31, 0x20);
+	snd_soc_component_write(component, ES8336_DAC_SET3_REG32, 0x00);
+	snd_soc_component_write(component, ES8336_DAC_VOLL_REG33, 0x00);
+	snd_soc_component_write(component, ES8336_DAC_VOLR_REG34, 0x00);
+	snd_soc_component_write(component, ES8336_SDP_ADCFMT_REG0A, 0x00);
+	snd_soc_component_write(component, ES8336_SDP_DACFMT_REG0B, 0x00);
+	snd_soc_component_write(component, ES8336_SYS_VMIDLOW_REG10, 0x11);
+	snd_soc_component_write(component, ES8336_SYS_VSEL_REG11, 0xFC);
+	snd_soc_component_write(component, ES8336_SYS_REF_REG12, 0x28);
+	snd_soc_component_write(component, ES8336_SYS_LP1_REG0E, 0x04);
+	snd_soc_component_write(component, ES8336_SYS_LP2_REG0F, 0x0C);
+	snd_soc_component_write(component, ES8336_DAC_PDN_REG2F, 0x11);
+	snd_soc_component_write(component, ES8336_HPMIX_SEL_REG13, 0x00);
+	snd_soc_component_write(component, ES8336_HPMIX_SWITCH_REG14, 0x88);
+	snd_soc_component_write(component, ES8336_HPMIX_PDN_REG15, 0x00);
+	snd_soc_component_write(component, ES8336_HPMIX_VOL_REG16, 0xBB);
+	snd_soc_component_write(component, ES8336_CPHP_PDN2_REG1A, 0x10);
+	snd_soc_component_write(component, ES8336_CPHP_LDOCTL_REG1B, 0x30);
+	snd_soc_component_write(component, ES8336_CPHP_PDN1_REG19, 0x02);
+	snd_soc_component_write(component, ES8336_CPHP_ICAL_VOL_REG18, 0x00);
+	snd_soc_component_write(component, ES8336_GPIO_SEL_REG4D, 0x02);
+	snd_soc_component_write(component, ES8336_GPIO_DEBUNCE_INT_REG4E, 0x02);
+	snd_soc_component_write(component, ES8336_TESTMODE_REG50, 0xA0);
+	snd_soc_component_write(component, ES8336_TEST1_REG51, 0x00);
+	snd_soc_component_write(component, ES8336_TEST2_REG52, 0x00);
+	snd_soc_component_write(component, ES8336_SYS_PDN_REG0D, 0x00);
+	snd_soc_component_write(component, ES8336_RESET_REG00, 0xC0);
+	msleep(50);
+	snd_soc_component_write(component, ES8336_ADC_PGAGAIN_REG23, 0x60);
+	snd_soc_component_write(component, ES8336_ADC_D2SEPGA_REG24, 0x01);
+	/* adc ds mode, HPF enable */
+	snd_soc_component_write(component, ES8336_ADC_DMIC_REG25, 0x08);
+	snd_soc_component_write(component, ES8336_ADC_ALC1_REG29, 0xcd);
+	snd_soc_component_write(component, ES8336_ADC_ALC2_REG2A, 0x08);
+	snd_soc_component_write(component, ES8336_ADC_ALC3_REG2B, 0xa0);
+	snd_soc_component_write(component, ES8336_ADC_ALC4_REG2C, 0x05);
+	snd_soc_component_write(component, ES8336_ADC_ALC5_REG2D, 0x06);
+	snd_soc_component_write(component, ES8336_ADC_ALC6_REG2E, 0x61);
+	return 0;
+}
+
+static int es8336_suspend(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static int es8336_resume(struct snd_soc_component *component)
+{
+	struct es8336_priv *es8336 = snd_soc_component_get_drvdata(component);
+	int ret;
+
+	es8336_reset(component); /* UPDATED BY DAVID,15-3-5 */
+	ret = snd_soc_component_read32(component, ES8336_CLKMGR_ADCDIV2_REG05);
+	if (!ret) {
+		es8336_init_regs(component);
+		snd_soc_component_write(component, ES8336_GPIO_SEL_REG4D, 0x02);
+		/* max debance time, enable interrupt, low active */
+		snd_soc_component_write(component, ES8336_GPIO_DEBUNCE_INT_REG4E, 0xf3);
+		/* es8336_set_bias_level(component, SND_SOC_BIAS_OFF); */
+		snd_soc_component_write(component, ES8336_CPHP_OUTEN_REG17, 0x00);
+		snd_soc_component_write(component, ES8336_DAC_PDN_REG2F, 0x11);
+		snd_soc_component_write(component, ES8336_CPHP_LDOCTL_REG1B, 0x03);
+		snd_soc_component_write(component, ES8336_CPHP_PDN2_REG1A, 0x22);
+		snd_soc_component_write(component, ES8336_CPHP_PDN1_REG19, 0x06);
+		snd_soc_component_write(component, ES8336_HPMIX_SWITCH_REG14, 0x00);
+		snd_soc_component_write(component, ES8336_HPMIX_PDN_REG15, 0x33);
+		snd_soc_component_write(component, ES8336_HPMIX_VOL_REG16, 0x00);
+		if (!es8336->hp_inserted)
+			snd_soc_component_write(component, ES8336_SYS_PDN_REG0D, 0x3F);
+		snd_soc_component_write(component, ES8336_SYS_LP1_REG0E, 0xFF);
+		snd_soc_component_write(component, ES8336_SYS_LP2_REG0F, 0xFF);
+		snd_soc_component_write(component, ES8336_CLKMGR_CLKSW_REG01, 0xF3);
+		snd_soc_component_write(component, ES8336_ADC_PDN_LINSEL_REG22, 0xc0);
+	}
+	return 0;
+}
+
+static irqreturn_t es8336_irq_handler(int irq, void *data)
+{
+	struct es8336_priv *es8336 = data;
+
+	queue_delayed_work(system_power_efficient_wq, &es8336->work,
+			   msecs_to_jiffies(es8336->debounce_time));
+
+	return IRQ_HANDLED;
+}
+
+static void hp_work(struct work_struct *work)
+{
+	struct es8336_priv *es8336;
+	int enable;
+
+	es8336 = container_of(work, struct es8336_priv, work.work);
+	enable = gpio_get_value(es8336->hp_det_gpio);
+	if (es8336->hp_det_invert)
+		enable = !enable;
+
+	es8336->hp_inserted = enable ? true : false;
+	if (!es8336->muted) {
+		if (es8336->hp_inserted)
+			es8336_enable_spk(es8336, false);
+		else
+			es8336_enable_spk(es8336, true);
+	}
+}
+
+static int es8336_probe(struct snd_soc_component *component)
+{
+	struct es8336_priv *es8336 = snd_soc_component_get_drvdata(component);
+	int ret = 0;
+
+	es8336_component = component;
+	ret = snd_soc_component_read32(component, ES8336_CLKMGR_ADCDIV2_REG05);
+	if (!ret) {
+		es8336_reset(component); /* UPDATED BY DAVID,15-3-5 */
+		ret = snd_soc_component_read32(component, ES8336_CLKMGR_ADCDIV2_REG05);
+		if (!ret) {
+			es8336_init_regs(component);
+			snd_soc_component_write(component, ES8336_GPIO_SEL_REG4D, 0x02);
+			/* max debance time, enable interrupt, low active */
+			snd_soc_component_write(component,
+				      ES8336_GPIO_DEBUNCE_INT_REG4E, 0xf3);
+
+			/* es8336_set_bias_level(codec, SND_SOC_BIAS_OFF); */
+			snd_soc_component_write(component, ES8336_CPHP_OUTEN_REG17, 0x00);
+			snd_soc_component_write(component, ES8336_DAC_PDN_REG2F, 0x11);
+			snd_soc_component_write(component, ES8336_CPHP_LDOCTL_REG1B, 0x03);
+			snd_soc_component_write(component, ES8336_CPHP_PDN2_REG1A, 0x22);
+			snd_soc_component_write(component, ES8336_CPHP_PDN1_REG19, 0x06);
+			snd_soc_component_write(component, ES8336_HPMIX_SWITCH_REG14, 0x00);
+			snd_soc_component_write(component, ES8336_HPMIX_PDN_REG15, 0x33);
+			snd_soc_component_write(component, ES8336_HPMIX_VOL_REG16, 0x00);
+			if (!es8336->hp_inserted)
+				snd_soc_component_write(component, ES8336_SYS_PDN_REG0D,
+					      0x3F);
+			snd_soc_component_write(component, ES8336_SYS_LP1_REG0E, 0xFF);
+			snd_soc_component_write(component, ES8336_SYS_LP2_REG0F, 0xFF);
+			snd_soc_component_write(component, ES8336_CLKMGR_CLKSW_REG01, 0xF3);
+			snd_soc_component_write(component,
+				      ES8336_ADC_PDN_LINSEL_REG22, 0xc0);
+		}
+	}
+
+	return ret;
+}
+
+static void es8336_remove(struct snd_soc_component *component)
+{
+	es8336_set_bias_level(component, SND_SOC_BIAS_OFF);
+}
+
+const struct regmap_config es8336_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.max_register	= ES8336_TEST3_REG53,
+	.cache_type	= REGCACHE_RBTREE,
+	.reg_defaults = es8336_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(es8336_reg_defaults),
+};
+
+static const struct snd_soc_component_driver soc_component_dev_es8336 = {
+	.probe =	es8336_probe,
+	.remove =	es8336_remove,
+	.suspend =	es8336_suspend,
+	.resume =	es8336_resume,
+	.set_bias_level = es8336_set_bias_level,
+
+	.controls = es8336_snd_controls,
+	.num_controls = ARRAY_SIZE(es8336_snd_controls),
+	.dapm_widgets = es8336_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(es8336_dapm_widgets),
+	.dapm_routes = es8336_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(es8336_dapm_routes),
+};
+
+static int es8336_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct es8336_priv *es8336;
+	struct gpio_desc *gpiod;
+	int ret = -1;
+	int hp_irq;
+
+	es8336 = devm_kzalloc(&i2c->dev, sizeof(*es8336), GFP_KERNEL);
+	if (!es8336)
+		return -ENOMEM;
+
+	es8336->debounce_time = 200;
+	es8336->hp_det_invert = 0;
+	es8336->pwr_count = 0;
+	es8336->hp_inserted = false;
+	es8336->muted = true;
+
+	es8336->regmap = devm_regmap_init_i2c(i2c, &es8336_regmap_config);
+	if (IS_ERR(es8336->regmap)) {
+		ret = PTR_ERR(es8336->regmap);
+		dev_err(&i2c->dev, "Failed to init regmap: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(i2c, es8336);
+
+	gpiod = devm_gpiod_get_index_optional(&i2c->dev, "sel", 0,
+							GPIOD_OUT_HIGH);
+
+	if (!gpiod) {
+		dev_info(&i2c->dev, "Can not get spk_ctl_gpio\n");
+		es8336->spk_ctl_gpio = INVALID_GPIO;
+	} else {
+		es8336->spk_ctl_gpio = desc_to_gpio(gpiod);
+		es8336->spk_active_level = 0;
+		es8336_enable_spk(es8336, false);
+	}
+
+	gpiod = devm_gpiod_get_index_optional(&i2c->dev, "det", 0,
+							GPIOD_IN);
+
+	if (!gpiod) {
+		dev_info(&i2c->dev, "Can not get hp_det_gpio\n");
+		es8336->hp_det_gpio = INVALID_GPIO;
+	} else {
+		es8336->hp_det_gpio = desc_to_gpio(gpiod);
+		INIT_DELAYED_WORK(&es8336->work, hp_work);
+		es8336->hp_det_invert = 0;
+		hp_irq = gpio_to_irq(es8336->hp_det_gpio);
+		ret = devm_request_threaded_irq(&i2c->dev, hp_irq, NULL,
+						es8336_irq_handler,
+						IRQF_TRIGGER_FALLING |
+						IRQF_TRIGGER_RISING |
+						IRQF_ONESHOT,
+						"es8336_interrupt", es8336);
+		if (ret < 0) {
+			dev_err(&i2c->dev, "request_irq failed: %d\n", ret);
+			return ret;
+		}
+
+		schedule_delayed_work(&es8336->work,
+				      msecs_to_jiffies(es8336->debounce_time));
+	}
+
+	ret = snd_soc_register_component(&i2c->dev,
+				     &soc_component_dev_es8336,
+				     &es8336_dai, 1);
+
+	return ret;
+}
+
+static  int es8336_i2c_remove(struct i2c_client *client)
+{
+	kfree(i2c_get_clientdata(client));
+	return 0;
+}
+
+static void es8336_i2c_shutdown(struct i2c_client *client)
+{
+	struct es8336_priv *es8336 = i2c_get_clientdata(client);
+
+	if (es8336_component != NULL) {
+		es8336_enable_spk(es8336, false);
+		msleep(20);
+		es8336_set_bias_level(es8336_component, SND_SOC_BIAS_OFF);
+	}
+}
+
+static const struct i2c_device_id es8336_i2c_id[] = {
+	{"es8336", 0},
+	{"10ES8336:00", 0},
+	{"10ES8336", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, es8336_i2c_id);
+
+static const struct of_device_id es8336_of_match[] = {
+	{ .compatible = "everest,es8336", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, es8336_of_match);
+
+static const struct acpi_device_id es8336_acpi_match[] = {
+	{ "ESSX8336", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, es8336_acpi_match);
+
+static struct i2c_driver es8336_i2c_driver = {
+	.driver = {
+		.name		= "es8336",
+		.of_match_table = es8336_of_match,
+		.acpi_match_table = es8336_acpi_match,
+	},
+	.probe    = es8336_i2c_probe,
+	.remove	= es8336_i2c_remove,
+	.shutdown = es8336_i2c_shutdown,
+	.id_table = es8336_i2c_id,
+};
+
+module_i2c_driver(es8336_i2c_driver);
+MODULE_DESCRIPTION("ASoC es8336 driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/es8336.h b/sound/soc/codecs/es8336.h
new file mode 100644
index 000000000000..d2c74c11ffd1
--- /dev/null
+++ b/sound/soc/codecs/es8336.h
@@ -0,0 +1,161 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright Everest Semiconductor Co.,Ltd
+ *           Phytium Information Technology Co.,Ltd
+ *
+ * Author: David Yang <yangxiaohua@everest-semi.com>
+ *         Yiqun Zhang <zhangyiqun@phytium.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ES8336_H
+#define _ES8336_H
+
+/* ES8336 register space */
+/*
+ * RESET Control
+ */
+#define ES8336_RESET_REG00             0x00
+/*
+ * Clock Managerment
+ */
+#define ES8336_CLKMGR_CLKSW_REG01      0x01
+#define ES8336_CLKMGR_CLKSEL_REG02     0x02
+#define ES8336_CLKMGR_ADCOSR_REG03     0x03
+#define ES8336_CLKMGR_ADCDIV1_REG04    0x04
+#define ES8336_CLKMGR_ADCDIV2_REG05    0x05
+#define ES8336_CLKMGR_DACDIV1_REG06    0x06
+#define ES8336_CLKMGR_DACDIV2_REG07    0x07
+#define ES8336_CLKMGR_CPDIV_REG08      0x08
+/*
+ * SDP Control
+ */
+#define ES8336_SDP_MS_BCKDIV_REG09     0x09
+#define ES8336_SDP_ADCFMT_REG0A        0x0a
+#define ES8336_SDP_DACFMT_REG0B        0x0b
+/*
+ * System Control
+ */
+#define ES8336_SYS_VMIDSEL_REG0C       0x0c
+#define ES8336_SYS_PDN_REG0D           0x0d
+#define ES8336_SYS_LP1_REG0E           0x0e
+#define ES8336_SYS_LP2_REG0F           0x0f
+#define ES8336_SYS_VMIDLOW_REG10       0x10
+#define ES8336_SYS_VSEL_REG11          0x11
+#define ES8336_SYS_REF_REG12           0x12
+/*
+ * HP Mixer
+ */
+#define ES8336_HPMIX_SEL_REG13         0x13
+#define ES8336_HPMIX_SWITCH_REG14      0x14
+#define ES8336_HPMIX_PDN_REG15         0x15
+#define ES8336_HPMIX_VOL_REG16         0x16
+/*
+ * Charge Pump Headphone driver
+ */
+#define ES8336_CPHP_OUTEN_REG17        0x17
+#define ES8336_CPHP_ICAL_VOL_REG18     0x18
+#define ES8336_CPHP_PDN1_REG19         0x19
+#define ES8336_CPHP_PDN2_REG1A         0x1a
+#define ES8336_CPHP_LDOCTL_REG1B       0x1b
+/*
+ * Calibration
+ */
+#define ES8336_CAL_TYPE_REG1C         0x1c
+#define ES8336_CAL_SET_REG1D          0x1d
+#define ES8336_CAL_HPLIV_REG1E        0x1e
+#define ES8336_CAL_HPRIV_REG1F        0x1f
+#define ES8336_CAL_HPLMV_REG20        0x20
+#define ES8336_CAL_HPRMV_REG21        0x21
+/*
+ * ADC Control
+ */
+#define ES8336_ADC_PDN_LINSEL_REG22   0x22
+#define ES8336_ADC_PGAGAIN_REG23      0x23
+#define ES8336_ADC_D2SEPGA_REG24      0x24
+#define ES8336_ADC_DMIC_REG25         0x25
+#define ES8336_ADC_MUTE_REG26         0x26
+#define ES8336_ADC_VOLUME_REG27       0x27
+#define ES8336_ADC_ALC1_REG29         0x29
+#define ES8336_ADC_ALC2_REG2A         0x2a
+#define ES8336_ADC_ALC3_REG2B         0x2b
+#define ES8336_ADC_ALC4_REG2C         0x2c
+#define ES8336_ADC_ALC5_REG2D         0x2d
+#define ES8336_ADC_ALC6_REG2E         0x2e
+/*
+ * DAC Control
+ */
+#define ES8336_DAC_PDN_REG2F          0x2f
+#define ES8336_DAC_SET1_REG30         0x30
+#define ES8336_DAC_SET2_REG31         0x31
+#define ES8336_DAC_SET3_REG32         0x32
+#define ES8336_DAC_VOLL_REG33         0x33
+#define ES8336_DAC_VOLR_REG34         0x34
+/*
+ * GPIO
+ */
+#define ES8336_GPIO_SEL_REG4D         0x4D
+#define ES8336_GPIO_DEBUNCE_INT_REG4E 0x4E
+#define ES8336_GPIO_FLAG              0x4F
+/*
+ * TEST MODE
+ */
+#define ES8336_TESTMODE_REG50         0x50
+#define ES8336_TEST1_REG51            0x51
+#define ES8336_TEST2_REG52            0x52
+#define ES8336_TEST3_REG53            0x53
+
+#define ES8336_IFACE            ES8336_SDP_MS_BCKDIV_REG09
+#define ES8336_ADC_IFACE        ES8336_SDP_ADCFMT_REG0A
+#define ES8336_DAC_IFACE        ES8336_SDP_DACFMT_REG0B
+
+#define ES8336_REGNUM      84
+
+/* REGISTER 0X01 CLOCK MANAGER */
+#define ES8336_CLKMGR_MCLK_DIV_MASK	(0X1<<7)
+#define ES8336_CLKMGR_MCLK_DIV_NML	(0X0<<7)
+#define ES8336_CLKMGR_MCLK_DIV_1	(0X1<<7)
+#define ES8336_CLKMGR_ADC_MCLK_MASK	(0X1<<3)
+#define ES8336_CLKMGR_ADC_MCLK_EN	(0X1<<3)
+#define ES8336_CLKMGR_ADC_MCLK_DIS	(0X0<<3)
+#define ES8336_CLKMGR_DAC_MCLK_MASK	(0X1<<2)
+#define ES8336_CLKMGR_DAC_MCLK_EN	(0X1<<2)
+#define ES8336_CLKMGR_DAC_MCLK_DIS	(0X0<<2)
+#define ES8336_CLKMGR_ADC_ANALOG_MASK	(0X1<<1)
+#define ES8336_CLKMGR_ADC_ANALOG_EN	(0X1<<1)
+#define ES8336_CLKMGR_ADC_ANALOG_DIS	(0X0<<1)
+#define ES8336_CLKMGR_DAC_ANALOG_MASK	(0X1<<0)
+#define ES8336_CLKMGR_DAC_ANALOG_EN	(0X1<<0)
+#define ES8336_CLKMGR_DAC_ANALOG_DIS	(0X0<<0)
+
+/* REGISTER 0X0A */
+#define ES8336_ADCWL_MASK	(0x7 << 2)
+#define ES8336_ADCWL_32		(0x4 << 2)
+#define ES8336_ADCWL_24		(0x0 << 2)
+#define ES8336_ADCWL_20		(0x1 << 2)
+#define ES8336_ADCWL_18		(0x2 << 2)
+#define ES8336_ADCWL_16		(0x3 << 2)
+#define ES8336_ADCFMT_MASK	(0x3 << 0)
+#define ES8336_ADCFMT_I2S	(0x0 << 0)
+#define ES8336_ADCWL_LEFT	(0x1 << 0)
+#define ES8336_ADCWL_RIGHT	(0x2 << 0)
+#define ES8336_ADCWL_PCM	(0x3 << 0)
+
+/* REGISTER 0X0B */
+#define ES8336_DACWL_MASK	(0x7 << 2)
+#define ES8336_DACWL_32		(0x4 << 2)
+#define ES8336_DACWL_24		(0x0 << 2)
+#define ES8336_DACWL_20		(0x1 << 2)
+#define ES8336_DACWL_18		(0x2 << 2)
+#define ES8336_DACWL_16		(0x3 << 2)
+#define ES8336_DACFMT_MASK	(0x3 << 0)
+#define ES8336_DACFMT_I2S	(0x0 << 0)
+#define ES8336_DACWL_LEFT	(0x1 << 0)
+#define ES8336_DACWL_RIGHT	(0x2 << 0)
+#define ES8336_DACWL_PCM	(0x3 << 0)
+
+#endif
diff --git a/sound/soc/codecs/es8388.c b/sound/soc/codecs/es8388.c
new file mode 100644
index 000000000000..c4a4d19219b4
--- /dev/null
+++ b/sound/soc/codecs/es8388.c
@@ -0,0 +1,819 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * es8388.c  --  ES8388 ALSA SoC Audio driver
+ *
+ * Copyright 2021 Phytium Technology
+ * Author: Yiqun Zhang <zhangyiqun@phytium.com.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/of_device.h>
+#include <linux/module.h>
+#include <linux/pm.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include "es8388.h"
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+
+static const unsigned int rates_12288[] = {
+	8000, 12000, 16000, 24000, 32000, 48000, 96000,
+};
+
+static const int ratios_12288[] = {
+	10, 7, 6, 4, 3, 2, 0,
+};
+
+static const struct snd_pcm_hw_constraint_list constraints_12288 = {
+	.count	= ARRAY_SIZE(rates_12288),
+	.list	= rates_12288,
+};
+
+static const unsigned int rates_11289[] = {
+	8018, 11025, 22050, 44100, 88200,
+};
+
+static const int ratios_11289[] = {
+	9, 7, 4, 2, 0,
+};
+
+static const struct snd_pcm_hw_constraint_list constraints_11289 = {
+	.count	= ARRAY_SIZE(rates_11289),
+	.list	= rates_11289,
+};
+
+#define ES8388_RATES (SNDRV_PCM_RATE_192000 | \
+		SNDRV_PCM_RATE_96000 | \
+		SNDRV_PCM_RATE_88200 | \
+		SNDRV_PCM_RATE_8000_48000)
+#define ES8388_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+		SNDRV_PCM_FMTBIT_S18_3LE | \
+		SNDRV_PCM_FMTBIT_S20_3LE | \
+		SNDRV_PCM_FMTBIT_S24_LE | \
+		SNDRV_PCM_FMTBIT_S32_LE)
+
+struct es8388_priv {
+	struct regmap *regmap;
+	struct clk *clk;
+	int playback_fs;
+	bool deemph;
+	int mclkdiv2;
+	const struct snd_pcm_hw_constraint_list *sysclk_constraints;
+	const int *mclk_ratios;
+	bool master;
+};
+
+/*
+ * ES8388 Controls
+ */
+static const char * const adcpol_txt[] = {"Normal", "L Invert", "R Invert",
+					  "L + R Invert"};
+static SOC_ENUM_SINGLE_DECL(adcpol,
+			    ES8388_ADCCONTROL6, 6, adcpol_txt);
+
+static const DECLARE_TLV_DB_SCALE(play_tlv, -3000, 100, 0);
+static const DECLARE_TLV_DB_SCALE(dac_adc_tlv, -9600, 50, 0);
+static const DECLARE_TLV_DB_SCALE(pga_tlv, 0, 300, 0);
+static const DECLARE_TLV_DB_SCALE(bypass_tlv, -1500, 300, 0);
+static const DECLARE_TLV_DB_SCALE(mic_tlv, 0, 300, 0);
+
+static const struct {
+	int rate;
+	unsigned int val;
+} deemph_settings[] = {
+	{ 0,     ES8388_DACCONTROL6_DEEMPH_OFF },
+	{ 32000, ES8388_DACCONTROL6_DEEMPH_32k },
+	{ 44100, ES8388_DACCONTROL6_DEEMPH_44_1k },
+	{ 48000, ES8388_DACCONTROL6_DEEMPH_48k },
+};
+
+static int es8388_set_deemph(struct snd_soc_component *component)
+{
+	struct es8388_priv *es8388 = snd_soc_component_get_drvdata(component);
+	int val, i, best;
+
+	/*
+	 * If we're using deemphasis select the nearest available sample
+	 * rate.
+	 */
+	if (es8388->deemph) {
+		best = 0;
+		for (i = 1; i < ARRAY_SIZE(deemph_settings); i++) {
+			if (abs(deemph_settings[i].rate - es8388->playback_fs) <
+			    abs(deemph_settings[best].rate - es8388->playback_fs))
+				best = i;
+		}
+
+		val = deemph_settings[best].val;
+	} else {
+		val = ES8388_DACCONTROL6_DEEMPH_OFF;
+	}
+
+	dev_dbg(component->dev, "Set deemphasis %d\n", val);
+
+	return snd_soc_component_update_bits(component, ES8388_DACCONTROL6,
+			ES8388_DACCONTROL6_DEEMPH_MASK, val);
+}
+
+static int es8388_get_deemph(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct es8388_priv *es8388 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = es8388->deemph;
+	return 0;
+}
+
+static int es8388_put_deemph(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct es8388_priv *es8388 = snd_soc_component_get_drvdata(component);
+	unsigned int deemph = ucontrol->value.integer.value[0];
+	int ret;
+
+	if (deemph > 1)
+		return -EINVAL;
+
+	ret = es8388_set_deemph(component);
+	if (ret < 0)
+		return ret;
+
+	es8388->deemph = deemph;
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new es8388_snd_controls[] = {
+	SOC_DOUBLE_R_TLV("Capture Digital Volume",
+		ES8388_ADCCONTROL8, ES8388_ADCCONTROL9,
+		 0, 0xc0, 1, dac_adc_tlv),
+
+	SOC_SINGLE_BOOL_EXT("DAC Deemphasis Switch", 0,
+		    es8388_get_deemph, es8388_put_deemph),
+
+	SOC_ENUM("Capture Polarity", adcpol),
+
+	SOC_SINGLE_TLV("Left Mixer Left Bypass Volume",
+			ES8388_DACCONTROL17, 3, 7, 1, bypass_tlv),
+	SOC_SINGLE_TLV("Left Mixer Right Bypass Volume",
+			ES8388_DACCONTROL19, 3, 7, 1, bypass_tlv),
+	SOC_SINGLE_TLV("Right Mixer Left Bypass Volume",
+			ES8388_DACCONTROL18, 3, 7, 1, bypass_tlv),
+	SOC_SINGLE_TLV("Right Mixer Right Bypass Volume",
+			ES8388_DACCONTROL20, 3, 7, 1, bypass_tlv),
+
+	SOC_DOUBLE_R_TLV("PCM Volume",
+			ES8388_LDACVOL, ES8388_RDACVOL,
+			0, ES8388_DACVOL_MAX, 1, dac_adc_tlv),
+
+	SOC_DOUBLE_R_TLV("Output 1 Playback Volume",
+			ES8388_LOUT1VOL, ES8388_ROUT1VOL,
+			0, ES8388_OUT1VOL_MAX, 0, play_tlv),
+
+	SOC_DOUBLE_R_TLV("Output 2 Playback Volume",
+			ES8388_LOUT2VOL, ES8388_ROUT2VOL,
+			0, ES8388_OUT2VOL_MAX, 0, play_tlv),
+
+	SOC_DOUBLE_TLV("Mic PGA Volume", ES8388_ADCCONTROL1,
+			4, 0, 8, 0, mic_tlv),
+};
+
+/*
+ * DAPM Controls
+ */
+static const char * const es8388_line_texts[] = {
+	"Line 1", "Line 2", "PGA", "Differential"};
+
+static const struct soc_enum es8388_lline_enum =
+	SOC_ENUM_SINGLE(ES8388_DACCONTROL16, 3,
+			      ARRAY_SIZE(es8388_line_texts),
+			      es8388_line_texts);
+static const struct snd_kcontrol_new es8388_left_line_controls =
+	SOC_DAPM_ENUM("Route", es8388_lline_enum);
+
+static const struct soc_enum es8388_rline_enum =
+	SOC_ENUM_SINGLE(ES8388_DACCONTROL16, 0,
+			      ARRAY_SIZE(es8388_line_texts),
+			      es8388_line_texts);
+static const struct snd_kcontrol_new es8388_right_line_controls =
+	SOC_DAPM_ENUM("Route", es8388_lline_enum);
+
+/* Left Mixer */
+static const struct snd_kcontrol_new es8388_left_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Playback Switch", ES8388_DACCONTROL17, 7, 1, 0),
+	SOC_DAPM_SINGLE("Left Bypass Switch", ES8388_DACCONTROL17, 6, 1, 0),
+	SOC_DAPM_SINGLE("Right Playback Switch", ES8388_DACCONTROL18, 7, 1, 0),
+	SOC_DAPM_SINGLE("Right Bypass Switch", ES8388_DACCONTROL18, 6, 1, 0),
+};
+
+/* Right Mixer */
+static const struct snd_kcontrol_new es8388_right_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Left Playback Switch", ES8388_DACCONTROL19, 7, 1, 0),
+	SOC_DAPM_SINGLE("Left Bypass Switch", ES8388_DACCONTROL19, 6, 1, 0),
+	SOC_DAPM_SINGLE("Playback Switch", ES8388_DACCONTROL20, 7, 1, 0),
+	SOC_DAPM_SINGLE("Right Bypass Switch", ES8388_DACCONTROL20, 6, 1, 0),
+};
+
+static const char * const es8388_pga_sel[] = {
+	"Line 1", "Line 2", "Line 3", "Differential"};
+
+/* Left PGA Mux */
+static const struct soc_enum es8388_lpga_enum =
+	SOC_ENUM_SINGLE(ES8388_ADCCONTROL2, 6,
+			      ARRAY_SIZE(es8388_pga_sel),
+			      es8388_pga_sel);
+static const struct snd_kcontrol_new es8388_left_pga_controls =
+	SOC_DAPM_ENUM("Route", es8388_lpga_enum);
+
+/* Right PGA Mux */
+static const struct soc_enum es8388_rpga_enum =
+	SOC_ENUM_SINGLE(ES8388_ADCCONTROL2, 4,
+			      ARRAY_SIZE(es8388_pga_sel),
+			      es8388_pga_sel);
+static const struct snd_kcontrol_new es8388_right_pga_controls =
+	SOC_DAPM_ENUM("Route", es8388_rpga_enum);
+
+/* Differential Mux */
+static const char * const es8388_diff_sel[] = {"Line 1", "Line 2"};
+static SOC_ENUM_SINGLE_DECL(diffmux,
+			    ES8388_ADCCONTROL3, 7, es8388_diff_sel);
+static const struct snd_kcontrol_new es8388_diffmux_controls =
+	SOC_DAPM_ENUM("Route", diffmux);
+
+/* Mono ADC Mux */
+static const char * const es8388_mono_mux[] = {"Stereo", "Mono (Left)",
+	"Mono (Right)", "Digital Mono"};
+static SOC_ENUM_SINGLE_DECL(monomux,
+			    ES8388_ADCCONTROL3, 3, es8388_mono_mux);
+static const struct snd_kcontrol_new es8388_monomux_controls =
+	SOC_DAPM_ENUM("Route", monomux);
+
+static const struct snd_soc_dapm_widget es8388_dapm_widgets[] = {
+	SND_SOC_DAPM_MUX("Differential Mux", SND_SOC_NOPM, 0, 0,
+		&es8388_diffmux_controls),
+	SND_SOC_DAPM_MUX("Left ADC Mux", SND_SOC_NOPM, 0, 0,
+		&es8388_monomux_controls),
+	SND_SOC_DAPM_MUX("Right ADC Mux", SND_SOC_NOPM, 0, 0,
+		&es8388_monomux_controls),
+
+	SND_SOC_DAPM_MUX("Left PGA Mux", ES8388_ADCPOWER,
+			ES8388_ADCPOWER_AINL_OFF, 1,
+			&es8388_left_pga_controls),
+	SND_SOC_DAPM_MUX("Right PGA Mux", ES8388_ADCPOWER,
+			ES8388_ADCPOWER_AINR_OFF, 1,
+			&es8388_right_pga_controls),
+
+	SND_SOC_DAPM_MUX("Left Line Mux", SND_SOC_NOPM, 0, 0,
+		&es8388_left_line_controls),
+	SND_SOC_DAPM_MUX("Right Line Mux", SND_SOC_NOPM, 0, 0,
+		&es8388_right_line_controls),
+
+	SND_SOC_DAPM_ADC("Right ADC", "Right Capture", ES8388_ADCPOWER,
+			ES8388_ADCPOWER_ADCR_OFF, 1),
+	SND_SOC_DAPM_ADC("Left ADC", "Left Capture", ES8388_ADCPOWER,
+			ES8388_ADCPOWER_ADCL_OFF, 1),
+
+	SND_SOC_DAPM_SUPPLY("DAC STM", ES8388_CHIPPOWER,
+			ES8388_CHIPPOWER_DACSTM_RESET, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("ADC STM", ES8388_CHIPPOWER,
+			ES8388_CHIPPOWER_ADCSTM_RESET, 1, NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("DAC DIG", ES8388_CHIPPOWER,
+			ES8388_CHIPPOWER_DACDIG_OFF, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("ADC DIG", ES8388_CHIPPOWER,
+			ES8388_CHIPPOWER_ADCDIG_OFF, 1, NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("DAC DLL", ES8388_CHIPPOWER,
+			ES8388_CHIPPOWER_DACDLL_OFF, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("ADC DLL", ES8388_CHIPPOWER,
+			ES8388_CHIPPOWER_ADCDLL_OFF, 1, NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("ADC Vref", ES8388_CHIPPOWER,
+			ES8388_CHIPPOWER_ADCVREF_OFF, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("DAC Vref", ES8388_CHIPPOWER,
+			ES8388_CHIPPOWER_DACVREF_OFF, 1, NULL, 0),
+
+	SND_SOC_DAPM_DAC("Right DAC", "Right Playback", ES8388_DACPOWER,
+			ES8388_DACPOWER_RDAC_OFF, 1),
+	SND_SOC_DAPM_DAC("Left DAC", "Left Playback", ES8388_DACPOWER,
+			ES8388_DACPOWER_LDAC_OFF, 1),
+
+	SND_SOC_DAPM_MIXER("Left Mixer", SND_SOC_NOPM, 0, 0,
+		&es8388_left_mixer_controls[0],
+		ARRAY_SIZE(es8388_left_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Mixer", SND_SOC_NOPM, 0, 0,
+		&es8388_right_mixer_controls[0],
+		ARRAY_SIZE(es8388_right_mixer_controls)),
+
+	SND_SOC_DAPM_PGA("Right Out 2", ES8388_DACPOWER,
+			ES8388_DACPOWER_ROUT2_ON, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 2", ES8388_DACPOWER,
+			ES8388_DACPOWER_LOUT2_ON, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Out 1", ES8388_DACPOWER,
+			ES8388_DACPOWER_ROUT1_ON, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 1", ES8388_DACPOWER,
+			ES8388_DACPOWER_LOUT1_ON, 0, NULL, 0),
+
+	SND_SOC_DAPM_OUTPUT("LOUT1"),
+	SND_SOC_DAPM_OUTPUT("ROUT1"),
+	SND_SOC_DAPM_OUTPUT("LOUT2"),
+	SND_SOC_DAPM_OUTPUT("ROUT2"),
+
+	SND_SOC_DAPM_INPUT("LINPUT1"),
+	SND_SOC_DAPM_INPUT("LINPUT2"),
+	SND_SOC_DAPM_INPUT("RINPUT1"),
+	SND_SOC_DAPM_INPUT("RINPUT2"),
+};
+
+static const struct snd_soc_dapm_route es8388_dapm_routes[] = {
+	{ "Left Line Mux", "Line 1", "LINPUT1" },
+	{ "Left Line Mux", "Line 2", "LINPUT2" },
+	{ "Left Line Mux", "PGA", "Left PGA Mux" },
+	{ "Left Line Mux", "Differential", "Differential Mux" },
+
+	{ "Right Line Mux", "Line 1", "RINPUT1" },
+	{ "Right Line Mux", "Line 2", "RINPUT2" },
+	{ "Right Line Mux", "PGA", "Right PGA Mux" },
+	{ "Right Line Mux", "Differential", "Differential Mux" },
+
+	{ "Left PGA Mux", "Line 1", "LINPUT1" },
+	{ "Left PGA Mux", "Line 2", "LINPUT2" },
+	{ "Left PGA Mux", "Differential", "Differential Mux" },
+
+	{ "Right PGA Mux", "Line 1", "RINPUT1" },
+	{ "Right PGA Mux", "Line 2", "RINPUT2" },
+	{ "Right PGA Mux", "Differential", "Differential Mux" },
+
+	{ "Differential Mux", "Line 1", "LINPUT1" },
+	{ "Differential Mux", "Line 1", "RINPUT1" },
+	{ "Differential Mux", "Line 2", "LINPUT2" },
+	{ "Differential Mux", "Line 2", "RINPUT2" },
+
+	{ "Left ADC Mux", "Stereo", "Left PGA Mux" },
+	{ "Left ADC Mux", "Mono (Left)", "Left PGA Mux" },
+	{ "Left ADC Mux", "Digital Mono", "Left PGA Mux" },
+
+	{ "Right ADC Mux", "Stereo", "Right PGA Mux" },
+	{ "Right ADC Mux", "Mono (Right)", "Right PGA Mux" },
+	{ "Right ADC Mux", "Digital Mono", "Right PGA Mux" },
+
+	{ "Left ADC", NULL, "Left ADC Mux" },
+	{ "Right ADC", NULL, "Right ADC Mux" },
+
+	{ "ADC DIG", NULL, "ADC STM" },
+	{ "ADC DIG", NULL, "ADC Vref" },
+	{ "ADC DIG", NULL, "ADC DLL" },
+
+	{ "Left ADC", NULL, "ADC DIG" },
+	{ "Right ADC", NULL, "ADC DIG" },
+
+	{ "Left Line Mux", "Line 1", "LINPUT1" },
+	{ "Left Line Mux", "Line 2", "LINPUT2" },
+	{ "Left Line Mux", "PGA", "Left PGA Mux" },
+	{ "Left Line Mux", "Differential", "Differential Mux" },
+
+	{ "Right Line Mux", "Line 1", "RINPUT1" },
+	{ "Right Line Mux", "Line 2", "RINPUT2" },
+	{ "Right Line Mux", "PGA", "Right PGA Mux" },
+	{ "Right Line Mux", "Differential", "Differential Mux" },
+
+	{ "Left Out 1", NULL, "Left DAC" },
+	{ "Right Out 1", NULL, "Right DAC" },
+	{ "Left Out 2", NULL, "Left DAC" },
+	{ "Right Out 2", NULL, "Right DAC" },
+
+	{ "Left Mixer", "Playback Switch", "Left DAC" },
+	{ "Left Mixer", "Left Bypass Switch", "Left Line Mux" },
+	{ "Left Mixer", "Right Playback Switch", "Right DAC" },
+	{ "Left Mixer", "Right Bypass Switch", "Right Line Mux" },
+
+	{ "Right Mixer", "Left Playback Switch", "Left DAC" },
+	{ "Right Mixer", "Left Bypass Switch", "Left Line Mux" },
+	{ "Right Mixer", "Playback Switch", "Right DAC" },
+	{ "Right Mixer", "Right Bypass Switch", "Right Line Mux" },
+
+	{ "DAC DIG", NULL, "DAC STM" },
+	{ "DAC DIG", NULL, "DAC Vref" },
+	{ "DAC DIG", NULL, "DAC DLL" },
+
+	{ "Left DAC", NULL, "DAC DIG" },
+	{ "Right DAC", NULL, "DAC DIG" },
+
+	{ "Left Out 1", NULL, "Left Mixer" },
+	{ "LOUT1", NULL, "Left Out 1" },
+	{ "Right Out 1", NULL, "Right Mixer" },
+	{ "ROUT1", NULL, "Right Out 1" },
+
+	{ "Left Out 2", NULL, "Left Mixer" },
+	{ "LOUT2", NULL, "Left Out 2" },
+	{ "Right Out 2", NULL, "Right Mixer" },
+	{ "ROUT2", NULL, "Right Out 2" },
+};
+
+static int es8388_mute(struct snd_soc_dai *dai, int mute)
+{
+	return snd_soc_component_update_bits(dai->component, ES8388_DACCONTROL3,
+			ES8388_DACCONTROL3_DACMUTE,
+			mute ? ES8388_DACCONTROL3_DACMUTE : 0);
+}
+
+static int es8388_startup(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct es8388_priv *es8388 = snd_soc_component_get_drvdata(component);
+
+	if (es8388->master && es8388->sysclk_constraints)
+		snd_pcm_hw_constraint_list(substream->runtime, 0,
+				SNDRV_PCM_HW_PARAM_RATE,
+				es8388->sysclk_constraints);
+
+	return 0;
+}
+
+static int es8388_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params,
+	struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct es8388_priv *es8388 = snd_soc_component_get_drvdata(component);
+	int i;
+	int reg;
+	int wl;
+	int ratio;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		reg = ES8388_DACCONTROL2;
+	else
+		reg = ES8388_ADCCONTROL5;
+
+	if (es8388->master) {
+		if (!es8388->sysclk_constraints) {
+			dev_err(component->dev, "No MCLK configured\n");
+			return -EINVAL;
+		}
+
+		for (i = 0; i < es8388->sysclk_constraints->count; i++)
+			if (es8388->sysclk_constraints->list[i] ==
+			    params_rate(params))
+				break;
+
+		if (i == es8388->sysclk_constraints->count) {
+			dev_err(component->dev,
+				"LRCLK %d unsupported with current clock\n",
+				params_rate(params));
+			return -EINVAL;
+		}
+		ratio = es8388->mclk_ratios[i];
+	} else {
+		ratio = 0;
+		es8388->mclkdiv2 = 0;
+	}
+
+	snd_soc_component_update_bits(component, ES8388_MASTERMODE,
+			ES8388_MASTERMODE_MCLKDIV2,
+			es8388->mclkdiv2 ? ES8388_MASTERMODE_MCLKDIV2 : 0);
+
+	switch (params_width(params)) {
+	case 16:
+		wl = 3;
+		break;
+	case 18:
+		wl = 2;
+		break;
+	case 20:
+		wl = 1;
+		break;
+	case 24:
+		wl = 0;
+		break;
+	case 32:
+		wl = 4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_component_update_bits(component, ES8388_DACCONTROL1,
+				ES8388_DACCONTROL1_DACWL_MASK,
+				wl << ES8388_DACCONTROL1_DACWL_SHIFT);
+
+		es8388->playback_fs = params_rate(params);
+		es8388_set_deemph(component);
+	} else
+		snd_soc_component_update_bits(component, ES8388_ADCCONTROL4,
+				ES8388_ADCCONTROL4_ADCWL_MASK,
+				wl << ES8388_ADCCONTROL4_ADCWL_SHIFT);
+
+	return snd_soc_component_update_bits(component, reg, ES8388_RATEMASK, ratio);
+}
+
+static int es8388_set_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	struct es8388_priv *es8388 = snd_soc_component_get_drvdata(component);
+	int mclkdiv2 = 0;
+
+	switch (freq) {
+	case 0:
+		es8388->sysclk_constraints = NULL;
+		es8388->mclk_ratios = NULL;
+		break;
+	case 22579200:
+		mclkdiv2 = 1;
+		/* fallthru */
+	case 11289600:
+		es8388->sysclk_constraints = &constraints_11289;
+		es8388->mclk_ratios = ratios_11289;
+		break;
+	case 24576000:
+		mclkdiv2 = 1;
+		/* fallthru */
+	case 12288000:
+		es8388->sysclk_constraints = &constraints_12288;
+		es8388->mclk_ratios = ratios_12288;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	es8388->mclkdiv2 = mclkdiv2;
+	return 0;
+}
+
+static int es8388_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	struct es8388_priv *es8388 = snd_soc_component_get_drvdata(component);
+	u8 dac_mode = 0;
+	u8 adc_mode = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		/* Master serial port mode, with BCLK generated automatically */
+		snd_soc_component_update_bits(component, ES8388_MASTERMODE,
+				    ES8388_MASTERMODE_MSC,
+				    ES8388_MASTERMODE_MSC);
+		es8388->master = true;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* Slave serial port mode */
+		snd_soc_component_update_bits(component, ES8388_MASTERMODE,
+				    ES8388_MASTERMODE_MSC, 0);
+		es8388->master = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		dac_mode |= ES8388_DACCONTROL1_DACFORMAT_I2S;
+		adc_mode |= ES8388_ADCCONTROL4_ADCFORMAT_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		dac_mode |= ES8388_DACCONTROL1_DACFORMAT_RJUST;
+		adc_mode |= ES8388_ADCCONTROL4_ADCFORMAT_RJUST;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		dac_mode |= ES8388_DACCONTROL1_DACFORMAT_LJUST;
+		adc_mode |= ES8388_ADCCONTROL4_ADCFORMAT_LJUST;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	if ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)
+		return -EINVAL;
+
+	snd_soc_component_update_bits(component, ES8388_DACCONTROL1,
+			ES8388_DACCONTROL1_DACFORMAT_MASK, dac_mode);
+	snd_soc_component_update_bits(component, ES8388_ADCCONTROL4,
+			ES8388_ADCCONTROL4_ADCFORMAT_MASK, adc_mode);
+
+	return 0;
+}
+
+static int es8388_set_bias_level(struct snd_soc_component *component,
+				 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		/* VREF, VMID=2x50k, digital enabled */
+		snd_soc_component_write(component, ES8388_CHIPPOWER, 0);
+		snd_soc_component_update_bits(component, ES8388_CONTROL1,
+				ES8388_CONTROL1_VMIDSEL_MASK |
+				ES8388_CONTROL1_ENREF,
+				ES8388_CONTROL1_VMIDSEL_50k |
+				ES8388_CONTROL1_ENREF);
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {
+			snd_soc_component_update_bits(component, ES8388_CONTROL1,
+					ES8388_CONTROL1_VMIDSEL_MASK |
+					ES8388_CONTROL1_ENREF,
+					ES8388_CONTROL1_VMIDSEL_5k |
+					ES8388_CONTROL1_ENREF);
+
+			/* Charge caps */
+			msleep(100);
+		}
+
+		snd_soc_component_write(component, ES8388_CONTROL2,
+				ES8388_CONTROL2_OVERCURRENT_ON |
+				ES8388_CONTROL2_THERMAL_SHUTDOWN_ON);
+
+		/* VREF, VMID=2*500k, digital stopped */
+		snd_soc_component_update_bits(component, ES8388_CONTROL1,
+				ES8388_CONTROL1_VMIDSEL_MASK |
+				ES8388_CONTROL1_ENREF,
+				ES8388_CONTROL1_VMIDSEL_500k |
+				ES8388_CONTROL1_ENREF);
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		snd_soc_component_update_bits(component, ES8388_CONTROL1,
+				ES8388_CONTROL1_VMIDSEL_MASK |
+				ES8388_CONTROL1_ENREF,
+				0);
+		break;
+	}
+	return 0;
+}
+
+static const struct snd_soc_dai_ops es8388_dai_ops = {
+	.startup	= es8388_startup,
+	.hw_params	= es8388_hw_params,
+	.digital_mute	= es8388_mute,
+	.set_sysclk	= es8388_set_sysclk,
+	.set_fmt	= es8388_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver es8388_dai = {
+	.name = "es8388-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = ES8388_RATES,
+		.formats = ES8388_FORMATS,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = ES8388_RATES,
+		.formats = ES8388_FORMATS,
+	},
+	.ops = &es8388_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static int es8388_suspend(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static int es8388_resume(struct snd_soc_component *component)
+{
+	struct regmap *regmap = dev_get_regmap(component->dev, NULL);
+	struct es8388_priv *es8388;
+	int ret;
+
+	es8388 = snd_soc_component_get_drvdata(component);
+
+	regcache_mark_dirty(regmap);
+	ret = regcache_sync(regmap);
+	if (ret) {
+		dev_err(component->dev, "unable to sync regcache\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int es8388_component_probe(struct snd_soc_component *component)
+{
+	snd_soc_component_write(component, ES8388_ADCPOWER, 0xf0);
+	snd_soc_component_write(component, ES8388_CONTROL1, 0x30);
+	snd_soc_component_write(component, ES8388_DACCONTROL21, 0x80);
+	snd_soc_component_write(component, ES8388_ADCCONTROL10, 0xda);
+
+	return 0;
+}
+
+static void es8388_remove(struct snd_soc_component *component)
+{
+}
+
+const struct regmap_config es8388_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.max_register	= ES8388_REG_MAX,
+	.cache_type	= REGCACHE_RBTREE,
+	.use_single_rw	= true,
+};
+EXPORT_SYMBOL_GPL(es8388_regmap_config);
+
+static const struct snd_soc_component_driver es8388_component_driver = {
+	.probe			= es8388_component_probe,
+	.remove			= es8388_remove,
+	.suspend		= es8388_suspend,
+	.resume			= es8388_resume,
+	.set_bias_level		= es8388_set_bias_level,
+	.controls		= es8388_snd_controls,
+	.num_controls		= ARRAY_SIZE(es8388_snd_controls),
+	.dapm_widgets		= es8388_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(es8388_dapm_widgets),
+	.dapm_routes		= es8388_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(es8388_dapm_routes),
+	.suspend_bias_off	= 1,
+	.idle_bias_on		= 1,
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
+};
+
+int es8388_probe(struct device *dev, struct regmap *regmap)
+{
+	struct es8388_priv *es8388;
+
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	es8388 = devm_kzalloc(dev, sizeof(*es8388), GFP_KERNEL);
+	if (es8388 == NULL)
+		return -ENOMEM;
+
+	es8388->regmap = regmap;
+
+	dev_set_drvdata(dev, es8388);
+
+	return devm_snd_soc_register_component(dev,
+			&es8388_component_driver, &es8388_dai, 1);
+}
+EXPORT_SYMBOL_GPL(es8388_probe);
+
+static const struct i2c_device_id es8388_id[] = {
+	{ "es8388", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, es8388_id);
+
+static const struct of_device_id es8388_of_match[] = {
+	{ .compatible = "everest,es8388", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, es8388_of_match);
+
+static struct acpi_device_id es8388_acpi_match[] = {
+	{"ESSX8388", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(acpi, es8388_acpi_match);
+
+static int es8388_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	return es8388_probe(&i2c->dev,
+			devm_regmap_init_i2c(i2c, &es8388_regmap_config));
+}
+
+static struct i2c_driver es8388_i2c_driver = {
+	.driver = {
+		.name		= "es8388",
+		.of_match_table = es8388_of_match,
+		.acpi_match_table = es8388_acpi_match,
+	},
+	.probe    = es8388_i2c_probe,
+	.id_table = es8388_id,
+};
+
+module_i2c_driver(es8388_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC ES8388 driver");
+MODULE_AUTHOR("Yiqun Zhang <zhangyiqun@phytium.com.cn>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/es8388.h b/sound/soc/codecs/es8388.h
new file mode 100644
index 000000000000..5858a71261fb
--- /dev/null
+++ b/sound/soc/codecs/es8388.h
@@ -0,0 +1,290 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * es8388.h  --  ES8388 ALSA SoC Audio driver
+ */
+
+#ifndef _ES8388_H
+#define _ES8388_H
+
+#include <linux/regmap.h>
+
+struct device;
+
+extern const struct regmap_config es8388_regmap_config;
+int es8388_probe(struct device *dev, struct regmap *regmap);
+
+#define ES8388_DACLVOL 46
+#define ES8388_DACRVOL 47
+#define ES8388_DACCTL 28
+#define ES8388_RATEMASK (0x1f << 0)
+
+#define ES8388_CONTROL1		0x00
+#define ES8388_CONTROL1_VMIDSEL_OFF (0 << 0)
+#define ES8388_CONTROL1_VMIDSEL_50k (1 << 0)
+#define ES8388_CONTROL1_VMIDSEL_500k (2 << 0)
+#define ES8388_CONTROL1_VMIDSEL_5k (3 << 0)
+#define ES8388_CONTROL1_VMIDSEL_MASK (3 << 0)
+#define ES8388_CONTROL1_ENREF (1 << 2)
+#define ES8388_CONTROL1_SEQEN (1 << 3)
+#define ES8388_CONTROL1_SAMEFS (1 << 4)
+#define ES8388_CONTROL1_DACMCLK_ADC (0 << 5)
+#define ES8388_CONTROL1_DACMCLK_DAC (1 << 5)
+#define ES8388_CONTROL1_LRCM (1 << 6)
+#define ES8388_CONTROL1_SCP_RESET (1 << 7)
+
+#define ES8388_CONTROL2		0x01
+#define ES8388_CONTROL2_VREF_BUF_OFF (1 << 0)
+#define ES8388_CONTROL2_VREF_LOWPOWER (1 << 1)
+#define ES8388_CONTROL2_IBIASGEN_OFF (1 << 2)
+#define ES8388_CONTROL2_ANALOG_OFF (1 << 3)
+#define ES8388_CONTROL2_VREF_BUF_LOWPOWER (1 << 4)
+#define ES8388_CONTROL2_VCM_MOD_LOWPOWER (1 << 5)
+#define ES8388_CONTROL2_OVERCURRENT_ON (1 << 6)
+#define ES8388_CONTROL2_THERMAL_SHUTDOWN_ON (1 << 7)
+
+#define ES8388_CHIPPOWER	0x02
+#define ES8388_CHIPPOWER_DACVREF_OFF 0
+#define ES8388_CHIPPOWER_ADCVREF_OFF 1
+#define ES8388_CHIPPOWER_DACDLL_OFF 2
+#define ES8388_CHIPPOWER_ADCDLL_OFF 3
+#define ES8388_CHIPPOWER_DACSTM_RESET 4
+#define ES8388_CHIPPOWER_ADCSTM_RESET 5
+#define ES8388_CHIPPOWER_DACDIG_OFF 6
+#define ES8388_CHIPPOWER_ADCDIG_OFF 7
+
+#define ES8388_ADCPOWER		0x03
+#define ES8388_ADCPOWER_INT1_LOWPOWER 0
+#define ES8388_ADCPOWER_FLASH_ADC_LOWPOWER 1
+#define ES8388_ADCPOWER_ADC_BIAS_GEN_OFF 2
+#define ES8388_ADCPOWER_MIC_BIAS_OFF 3
+#define ES8388_ADCPOWER_ADCR_OFF 4
+#define ES8388_ADCPOWER_ADCL_OFF 5
+#define ES8388_ADCPOWER_AINR_OFF 6
+#define ES8388_ADCPOWER_AINL_OFF 7
+
+#define ES8388_DACPOWER		0x04
+#define ES8388_DACPOWER_OUT3_ON 0
+#define ES8388_DACPOWER_MONO_ON 1
+#define ES8388_DACPOWER_ROUT2_ON 2
+#define ES8388_DACPOWER_LOUT2_ON 3
+#define ES8388_DACPOWER_ROUT1_ON 4
+#define ES8388_DACPOWER_LOUT1_ON 5
+#define ES8388_DACPOWER_RDAC_OFF 6
+#define ES8388_DACPOWER_LDAC_OFF 7
+
+#define ES8388_CHIPLOPOW1	0x05
+#define ES8388_CHIPLOPOW2	0x06
+#define ES8388_ANAVOLMANAG	0x07
+
+#define ES8388_MASTERMODE	0x08
+#define ES8388_MASTERMODE_BCLKDIV (0 << 0)
+#define ES8388_MASTERMODE_BCLK_INV (1 << 5)
+#define ES8388_MASTERMODE_MCLKDIV2 (1 << 6)
+#define ES8388_MASTERMODE_MSC (1 << 7)
+
+#define ES8388_ADCCONTROL1	0x09
+#define ES8388_ADCCONTROL2	0x0a
+#define ES8388_ADCCONTROL3	0x0b
+
+#define ES8388_ADCCONTROL4	0x0c
+#define ES8388_ADCCONTROL4_ADCFORMAT_MASK (3 << 0)
+#define ES8388_ADCCONTROL4_ADCFORMAT_I2S (0 << 0)
+#define ES8388_ADCCONTROL4_ADCFORMAT_LJUST (1 << 0)
+#define ES8388_ADCCONTROL4_ADCFORMAT_RJUST (2 << 0)
+#define ES8388_ADCCONTROL4_ADCFORMAT_PCM (3 << 0)
+#define ES8388_ADCCONTROL4_ADCWL_SHIFT 2
+#define ES8388_ADCCONTROL4_ADCWL_MASK (7 << 2)
+#define ES8388_ADCCONTROL4_ADCLRP_I2S_POL_NORMAL (0 << 5)
+#define ES8388_ADCCONTROL4_ADCLRP_I2S_POL_INV (1 << 5)
+#define ES8388_ADCCONTROL4_ADCLRP_PCM_MSB_CLK2 (0 << 5)
+#define ES8388_ADCCONTROL4_ADCLRP_PCM_MSB_CLK1 (1 << 5)
+
+#define ES8388_ADCCONTROL5	0x0d
+#define ES8388_ADCCONTROL5_RATEMASK (0x1f << 0)
+
+#define ES8388_ADCCONTROL6	0x0e
+
+#define ES8388_ADCCONTROL7	0x0f
+#define ES8388_ADCCONTROL7_ADC_MUTE (1 << 2)
+#define ES8388_ADCCONTROL7_ADC_LER (1 << 3)
+#define ES8388_ADCCONTROL7_ADC_ZERO_CROSS (1 << 4)
+#define ES8388_ADCCONTROL7_ADC_SOFT_RAMP (1 << 5)
+#define ES8388_ADCCONTROL7_ADC_RAMP_RATE_4 (0 << 6)
+#define ES8388_ADCCONTROL7_ADC_RAMP_RATE_8 (1 << 6)
+#define ES8388_ADCCONTROL7_ADC_RAMP_RATE_16 (2 << 6)
+#define ES8388_ADCCONTROL7_ADC_RAMP_RATE_32 (3 << 6)
+
+#define ES8388_ADCCONTROL8	0x10
+#define ES8388_ADCCONTROL9	0x11
+#define ES8388_ADCCONTROL10	0x12
+#define ES8388_ADCCONTROL11	0x13
+#define ES8388_ADCCONTROL12	0x14
+#define ES8388_ADCCONTROL13	0x15
+#define ES8388_ADCCONTROL14	0x16
+
+#define ES8388_DACCONTROL1	0x17
+#define ES8388_DACCONTROL1_DACFORMAT_MASK (3 << 1)
+#define ES8388_DACCONTROL1_DACFORMAT_I2S (0 << 1)
+#define ES8388_DACCONTROL1_DACFORMAT_LJUST (1 << 1)
+#define ES8388_DACCONTROL1_DACFORMAT_RJUST (2 << 1)
+#define ES8388_DACCONTROL1_DACFORMAT_PCM (3 << 1)
+#define ES8388_DACCONTROL1_DACWL_SHIFT 3
+#define ES8388_DACCONTROL1_DACWL_MASK (7 << 3)
+#define ES8388_DACCONTROL1_DACLRP_I2S_POL_NORMAL (0 << 6)
+#define ES8388_DACCONTROL1_DACLRP_I2S_POL_INV (1 << 6)
+#define ES8388_DACCONTROL1_DACLRP_PCM_MSB_CLK2 (0 << 6)
+#define ES8388_DACCONTROL1_DACLRP_PCM_MSB_CLK1 (1 << 6)
+#define ES8388_DACCONTROL1_LRSWAP (1 << 7)
+
+#define ES8388_DACCONTROL2	0x18
+#define ES8388_DACCONTROL2_RATEMASK (0x1f << 0)
+#define ES8388_DACCONTROL2_DOUBLESPEED (1 << 5)
+
+#define ES8388_DACCONTROL3	0x19
+#define ES8388_DACCONTROL3_AUTOMUTE (1 << 2)
+#define ES8388_DACCONTROL3_DACMUTE (1 << 2)
+#define ES8388_DACCONTROL3_LEFTGAINVOL (1 << 3)
+#define ES8388_DACCONTROL3_DACZEROCROSS (1 << 4)
+#define ES8388_DACCONTROL3_DACSOFTRAMP (1 << 5)
+#define ES8388_DACCONTROL3_DACRAMPRATE (3 << 6)
+
+#define ES8388_LDACVOL 0x1a
+#define ES8388_LDACVOL_MASK (0 << 0)
+#define ES8388_LDACVOL_MAX (0xc0)
+
+#define ES8388_RDACVOL 0x1b
+#define ES8388_RDACVOL_MASK (0 << 0)
+#define ES8388_RDACVOL_MAX (0xc0)
+
+#define ES8388_DACVOL_MAX (0xc0)
+
+#define ES8388_DACCONTROL4	0x1a
+#define ES8388_DACCONTROL5	0x1b
+
+#define ES8388_DACCONTROL6	0x1c
+#define ES8388_DACCONTROL6_CLICKFREE (1 << 3)
+#define ES8388_DACCONTROL6_DAC_INVR (1 << 4)
+#define ES8388_DACCONTROL6_DAC_INVL (1 << 5)
+#define ES8388_DACCONTROL6_DEEMPH_MASK (3 << 6)
+#define ES8388_DACCONTROL6_DEEMPH_OFF (0 << 6)
+#define ES8388_DACCONTROL6_DEEMPH_32k (1 << 6)
+#define ES8388_DACCONTROL6_DEEMPH_44_1k (2 << 6)
+#define ES8388_DACCONTROL6_DEEMPH_48k (3 << 6)
+
+#define ES8388_DACCONTROL7	0x1d
+#define ES8388_DACCONTROL7_VPP_SCALE_3p5	(0 << 0)
+#define ES8388_DACCONTROL7_VPP_SCALE_4p0	(1 << 0)
+#define ES8388_DACCONTROL7_VPP_SCALE_3p0	(2 << 0)
+#define ES8388_DACCONTROL7_VPP_SCALE_2p5	(3 << 0)
+#define ES8388_DACCONTROL7_SHELVING_STRENGTH (1 << 2) /* In eights */
+#define ES8388_DACCONTROL7_MONO		(1 << 5)
+#define ES8388_DACCONTROL7_ZEROR	(1 << 6)
+#define ES8388_DACCONTROL7_ZEROL	(1 << 7)
+
+/* Shelving filter */
+#define ES8388_DACCONTROL8	0x1e
+#define ES8388_DACCONTROL9	0x1f
+#define ES8388_DACCONTROL10	0x20
+#define ES8388_DACCONTROL11	0x21
+#define ES8388_DACCONTROL12	0x22
+#define ES8388_DACCONTROL13	0x23
+#define ES8388_DACCONTROL14	0x24
+#define ES8388_DACCONTROL15	0x25
+
+#define ES8388_DACCONTROL16	0x26
+#define ES8388_DACCONTROL16_RMIXSEL_RIN1 (0 << 0)
+#define ES8388_DACCONTROL16_RMIXSEL_RIN2 (1 << 0)
+#define ES8388_DACCONTROL16_RMIXSEL_RIN3 (2 << 0)
+#define ES8388_DACCONTROL16_RMIXSEL_RADC (3 << 0)
+#define ES8388_DACCONTROL16_LMIXSEL_LIN1 (0 << 3)
+#define ES8388_DACCONTROL16_LMIXSEL_LIN2 (1 << 3)
+#define ES8388_DACCONTROL16_LMIXSEL_LIN3 (2 << 3)
+#define ES8388_DACCONTROL16_LMIXSEL_LADC (3 << 3)
+
+#define ES8388_DACCONTROL17	0x27
+#define ES8388_DACCONTROL17_LI2LOVOL (7 << 3)
+#define ES8388_DACCONTROL17_LI2LO (1 << 6)
+#define ES8388_DACCONTROL17_LD2LO (1 << 7)
+
+#define ES8388_DACCONTROL18	0x28
+#define ES8388_DACCONTROL18_RI2LOVOL (7 << 3)
+#define ES8388_DACCONTROL18_RI2LO (1 << 6)
+#define ES8388_DACCONTROL18_RD2LO (1 << 7)
+
+#define ES8388_DACCONTROL19	0x29
+#define ES8388_DACCONTROL19_LI2ROVOL (7 << 3)
+#define ES8388_DACCONTROL19_LI2RO (1 << 6)
+#define ES8388_DACCONTROL19_LD2RO (1 << 7)
+
+#define ES8388_DACCONTROL20	0x2a
+#define ES8388_DACCONTROL20_RI2ROVOL (7 << 3)
+#define ES8388_DACCONTROL20_RI2RO (1 << 6)
+#define ES8388_DACCONTROL20_RD2RO (1 << 7)
+
+#define ES8388_DACCONTROL21	0x2b
+#define ES8388_DACCONTROL21_LI2MOVOL (7 << 3)
+#define ES8388_DACCONTROL21_LI2MO (1 << 6)
+#define ES8388_DACCONTROL21_LD2MO (1 << 7)
+
+#define ES8388_DACCONTROL22	0x2c
+#define ES8388_DACCONTROL22_RI2MOVOL (7 << 3)
+#define ES8388_DACCONTROL22_RI2MO (1 << 6)
+#define ES8388_DACCONTROL22_RD2MO (1 << 7)
+
+#define ES8388_DACCONTROL23	0x2d
+#define ES8388_DACCONTROL23_MOUTINV		(1 << 1)
+#define ES8388_DACCONTROL23_HPSWPOL		(1 << 2)
+#define ES8388_DACCONTROL23_HPSWEN		(1 << 3)
+#define ES8388_DACCONTROL23_VROI_1p5k		(0 << 4)
+#define ES8388_DACCONTROL23_VROI_40k		(1 << 4)
+#define ES8388_DACCONTROL23_OUT3_VREF		(0 << 5)
+#define ES8388_DACCONTROL23_OUT3_ROUT1		(1 << 5)
+#define ES8388_DACCONTROL23_OUT3_MONOOUT	(2 << 5)
+#define ES8388_DACCONTROL23_OUT3_RIGHT_MIXER	(3 << 5)
+#define ES8388_DACCONTROL23_ROUT2INV		(1 << 7)
+
+/* LOUT1 Amplifier */
+#define ES8388_LOUT1VOL 0x2e
+#define ES8388_LOUT1VOL_MASK (0 << 5)
+#define ES8388_LOUT1VOL_MAX (0x24)
+
+/* ROUT1 Amplifier */
+#define ES8388_ROUT1VOL 0x2f
+#define ES8388_ROUT1VOL_MASK (0 << 5)
+#define ES8388_ROUT1VOL_MAX (0x24)
+
+#define ES8388_OUT1VOL_MAX (0x24)
+
+/* LOUT2 Amplifier */
+#define ES8388_LOUT2VOL 0x30
+#define ES8388_LOUT2VOL_MASK (0 << 5)
+#define ES8388_LOUT2VOL_MAX (0x24)
+
+/* ROUT2 Amplifier */
+#define ES8388_ROUT2VOL 0x31
+#define ES8388_ROUT2VOL_MASK (0 << 5)
+#define ES8388_ROUT2VOL_MAX (0x24)
+
+#define ES8388_OUT2VOL_MAX (0x24)
+
+/* Mono Out Amplifier */
+#define ES8388_MONOOUTVOL 0x32
+#define ES8388_MONOOUTVOL_MASK (0 << 5)
+#define ES8388_MONOOUTVOL_MAX (0x24)
+
+#define ES8388_DACCONTROL29	0x33
+#define ES8388_DACCONTROL30	0x34
+
+#define ES8388_SYSCLK		0
+
+#define ES8388_REG_MAX		0x35
+
+#define ES8388_1536FS		1536
+#define ES8388_1024FS		1024
+#define ES8388_768FS		768
+#define ES8388_512FS		512
+#define ES8388_384FS		384
+#define ES8388_256FS		256
+#define ES8388_128FS		128
+
+#endif
diff --git a/sound/soc/codecs/hdmi-codec.c b/sound/soc/codecs/hdmi-codec.c
index 7994e8ddc7d2..44914e7986f5 100644
--- a/sound/soc/codecs/hdmi-codec.c
+++ b/sound/soc/codecs/hdmi-codec.c
@@ -17,6 +17,7 @@
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
+#include <sound/jack.h>
 #include <sound/soc.h>
 #include <sound/tlv.h>
 #include <sound/pcm_drm_eld.h>
@@ -285,6 +286,8 @@ struct hdmi_codec_priv {
 	uint8_t eld[MAX_ELD_BYTES];
 	struct snd_pcm_chmap *chmap_info;
 	unsigned int chmap_idx;
+	struct snd_soc_jack *jack;
+	unsigned int jack_status;
 };
 
 static const struct snd_soc_dapm_widget hdmi_widgets[] = {
@@ -700,6 +703,44 @@ static int hdmi_dai_probe(struct snd_soc_dai *dai)
 	return snd_soc_dapm_add_routes(dapm, &route, 1);
 }
 
+static void hdmi_codec_jack_report(struct hdmi_codec_priv *hcp,
+				   unsigned int jack_status)
+{
+	if (hcp->jack && jack_status != hcp->jack_status) {
+		snd_soc_jack_report(hcp->jack, jack_status, SND_JACK_LINEOUT);
+		hcp->jack_status = jack_status;
+	}
+}
+
+static void plugged_cb(struct device *dev, bool plugged)
+{
+	struct hdmi_codec_priv *hcp = dev_get_drvdata(dev);
+
+	if (plugged)
+		hdmi_codec_jack_report(hcp, SND_JACK_LINEOUT);
+	else
+		hdmi_codec_jack_report(hcp, 0);
+}
+
+static int hdmi_codec_set_jack(struct snd_soc_component *component,
+			      struct snd_soc_jack *jack,
+			      void *data)
+{
+	struct hdmi_codec_priv *hcp = snd_soc_component_get_drvdata(component);
+	int ret = -EOPNOTSUPP;
+
+	if (hcp->hcd.ops->hook_plugged_cb) {
+		hcp->jack = jack;
+		ret = hcp->hcd.ops->hook_plugged_cb(component->dev->parent,
+						    hcp->hcd.data,
+						    plugged_cb,
+						    component->dev);
+		if (ret)
+			hcp->jack = NULL;
+	}
+	return ret;
+}
+
 static const struct snd_soc_dai_driver hdmi_i2s_dai = {
 	.name = "i2s-hifi",
 	.id = DAI_ID_I2S,
@@ -751,6 +792,7 @@ static const struct snd_soc_component_driver hdmi_driver = {
 	.use_pmdown_time	= 1,
 	.endianness		= 1,
 	.non_legacy_dai_naming	= 1,
+	.set_jack		= hdmi_codec_set_jack,
 };
 
 static int hdmi_codec_probe(struct platform_device *pdev)
-- 
Armbian

