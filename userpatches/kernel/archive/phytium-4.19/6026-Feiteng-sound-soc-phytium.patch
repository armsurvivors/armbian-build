From d59e8d75f153301ba52820b6f40eb207e59ff7e3 Mon Sep 17 00:00:00 2001
From: Ricardo Pardini <ricardo@pardini.net>
Date: Thu, 4 Aug 2022 21:49:10 +0200
Subject: Feiteng sound/soc/phytium

Feiteng sound/soc/phytium
---
 sound/soc/phytium/Kconfig       |   31 +
 sound/soc/phytium/Makefile      |   13 +
 sound/soc/phytium/local.h       |  326 +++
 sound/soc/phytium/phytium_i2s.c | 1345 ++++++++++
 sound/soc/phytium/pmdk_dp.c     |  227 ++
 sound/soc/phytium/pmdk_es8336.c |  100 +
 sound/soc/phytium/pmdk_es8388.c |  174 ++
 7 files changed, 2216 insertions(+)

diff --git a/sound/soc/phytium/Kconfig b/sound/soc/phytium/Kconfig
new file mode 100644
index 000000000000..4f9f12ce26b1
--- /dev/null
+++ b/sound/soc/phytium/Kconfig
@@ -0,0 +1,31 @@
+config SND_SOC_PHYTIUM_I2S
+	bool "Phytium I2S Device Driver"
+	depends on ARCH_PHYTIUM
+	help
+	 Say Y or M if you want to add support for I2S driver for
+	 Phytium I2S device . The device supports 2 channels each
+	 for play and record.
+
+config SND_PMDK_ES8388
+	tristate "Phytium X100 machine support with ES8388"
+	depends on I2C && SND_SOC_PHYTIUM_I2S
+	select SND_SOC_ES8388
+	help
+	 Say Y if you want to add Phytium machine support for
+	 ES8388 codecs.
+
+config SND_PMDK_ES8336
+	tristate "Phytium X100 machine support with ES8336"
+	depends on I2C && SND_SOC_PHYTIUM_I2S
+	select SND_SOC_ES8336
+	help
+	 Say Y if you want to add Phytium machine support for
+	 ES8336 codecs.
+
+config SND_PMDK_DP
+	tristate "Phytium machine support with X100 DP"
+	depends on I2C && SND_SOC_PHYTIUM_I2S
+	select SND_SOC_HDMI_CODEC
+	help
+	 Say Y if you want to add Phytium machine support for
+	 Displayport on X100.
diff --git a/sound/soc/phytium/Makefile b/sound/soc/phytium/Makefile
new file mode 100644
index 000000000000..db3c0659e844
--- /dev/null
+++ b/sound/soc/phytium/Makefile
@@ -0,0 +1,13 @@
+# PHYTIUM Platform Support
+
+snd-soc-phytium-i2s-objs :=phytium_i2s.o
+obj-$(CONFIG_SND_SOC_PHYTIUM_I2S) += snd-soc-phytium-i2s.o
+
+snd-soc-pmdk-es8388-objs :=pmdk_es8388.o
+obj-$(CONFIG_SND_PMDK_ES8388) += snd-soc-pmdk-es8388.o
+
+snd-soc-pmdk-es8336-objs :=pmdk_es8336.o
+obj-$(CONFIG_SND_PMDK_ES8336) += snd-soc-pmdk-es8336.o
+
+snd-soc-pmdk-dp-objs :=pmdk_dp.o
+obj-$(CONFIG_SND_PMDK_DP) += snd-soc-pmdk-dp.o
diff --git a/sound/soc/phytium/local.h b/sound/soc/phytium/local.h
new file mode 100644
index 000000000000..43e989c36fd8
--- /dev/null
+++ b/sound/soc/phytium/local.h
@@ -0,0 +1,326 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020-2021, Phytium Technology Co.,Ltd.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PHYTIUM_I2S_LOCAL_H
+#define __PHYTIUM_I2S_LOCAL_H
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <sound/designware_i2s.h>
+
+/* I2S clk setting*/
+#define CLK_CFG0	0xc00
+#define CLK_CFG1	0xc04
+
+/* common register for all channel */
+#define I2S_IER		0x000
+#define IRER		0x004
+#define ITER		0x008
+#define CER		0x00C
+
+#define RXFFR		0x014
+#define TXFFR		0x018
+
+/* Interrupt status register fields */
+#define ISR_TXFO	BIT(5)
+#define ISR_TXFE	BIT(4)
+#define ISR_RXFO	BIT(1)
+#define ISR_RXDA	BIT(0)
+
+/* I2STxRxRegisters for all channels */
+#define LRBR_LTHR(x)	(0x40 * x + 0x020)
+#define RRBR_RTHR(x)	(0x40 * x + 0x024)
+#define RER(x)		(0x40 * x + 0x028)
+
+#define RCR(x)		(0x40 * x + 0x030)
+
+#define ISR(x)		(0x40 * x + 0x038)
+#define IMR(x)		(0x40 * x + 0x03C)
+#define ROR(x)		(0x40 * x + 0x040)
+#define TOR(x)		(0x40 * x + 0x044)
+#define RFCR(x)		(0x40 * x + 0x048)
+#define TFCR(x)		(0x40 * x + 0x04C)
+#define RFF(x)		(0x40 * x + 0x050)
+#define TFF(x)		(0x40 * x + 0x054)
+
+/*enable txd and rxd block channel0~3 */
+#define TER(x)		(0x40 * x + 0x02C)
+#define CCR		0x010
+#define TCR(x)		(0x40 * x + 0x034)
+
+
+/* I2SCOMPRegisters */
+#define I2S_COMP_PARAM_2	0x01F0
+#define I2S_COMP_PARAM_1	0x01F4
+#define I2S_COMP_VERSION	0x01F8
+#define I2S_COMP_TYPE		0x01FC
+
+/***I2S AND DMA***/
+
+#define DMA_GCAP		0x0024
+
+#define DMA_CHAL_CONFG1		0x0028
+
+#define DMA_CHAL_CONFG0		0x0004
+#define DMA_MASK_INT		0x000c
+#define DMA_BDLPU(x)		(0x40 * x + 0x0040)
+#define DMA_BDLPL(x)		(0x40 * x + 0x0044)
+#define DMA_CHALX_DEV_ADDR(x)	(0x40 * x + 0x0048)
+#define DMA_CHALX_CBL(x)	(0x40 * x + 0x0054)
+#define DMA_CHALX_LVI(x)	(0x40 * x + 0x004c)
+
+#define DMA_CHALX_DSIZE(x)	(0x40 * x + 0x0064)
+#define DMA_CHALX_DLENTH(x)	(0x40 * x + 0x0068)
+#define DMA_CHALX_CTL(x)	(0x40 * x + 0x0058)
+
+
+#define DMA_CTL			0x0000
+
+#define DMA_LPIB(x)		(0x40 * x + 0x0050)
+
+#define DMA_STS			0x0008
+
+/****************/
+
+
+/* max number of fragments - we may use more if allocating more pages for BDL */
+#define BDL_SIZE		4096
+#define AZX_MAX_BDL_ENTRIES	(BDL_SIZE / 16)
+
+/*
+ * Component parameter register fields - define the I2S block's
+ * configuration.
+ */
+#define	COMP1_TX_WORDSIZE_3(r)	(((r) & GENMASK(27, 25)) >> 25)
+#define	COMP1_TX_WORDSIZE_2(r)	(((r) & GENMASK(24, 22)) >> 22)
+#define	COMP1_TX_WORDSIZE_1(r)	(((r) & GENMASK(21, 19)) >> 19)
+#define	COMP1_TX_WORDSIZE_0(r)	(((r) & GENMASK(18, 16)) >> 16)
+#define	COMP1_TX_CHANNELS(r)	(((r) & GENMASK(10, 9)) >> 9)
+#define	COMP1_RX_CHANNELS(r)	(((r) & GENMASK(8, 7)) >> 7)
+#define	COMP1_RX_ENABLED(r)	(((r) & BIT(6)) >> 6)
+#define	COMP1_TX_ENABLED(r)	(((r) & BIT(5)) >> 5)
+#define	COMP1_MODE_EN(r)	(((r) & BIT(4)) >> 4)
+#define	COMP1_FIFO_DEPTH_GLOBAL(r)	(((r) & GENMASK(3, 2)) >> 2)
+#define	COMP1_APB_DATA_WIDTH(r)	(((r) & GENMASK(1, 0)) >> 0)
+
+#define	COMP2_RX_WORDSIZE_3(r)	(((r) & GENMASK(12, 10)) >> 10)
+#define	COMP2_RX_WORDSIZE_2(r)	(((r) & GENMASK(9, 7)) >> 7)
+#define	COMP2_RX_WORDSIZE_1(r)	(((r) & GENMASK(5, 3)) >> 3)
+#define	COMP2_RX_WORDSIZE_0(r)	(((r) & GENMASK(2, 0)) >> 0)
+
+/* Number of entries in WORDSIZE and DATA_WIDTH parameter registers */
+#define	COMP_MAX_WORDSIZE	(1 << 3)
+#define	COMP_MAX_DATA_WIDTH	(1 << 2)
+
+#define MAX_CHANNEL_NUM		8
+#define MIN_CHANNEL_NUM		2
+
+#define azx_bus(chip)	(&(chip)->bus.core)
+#define bus_to_azx(_bus)	container_of(_bus, struct azx, bus.core)
+
+#define I2S_UNSOL_QUEUE_SIZE	64
+#define I2S_MAX_CODECS		8	/* limit by controller side */
+
+
+#define azx_stream(dev)		(&(dev)->core)
+
+struct i2sc_bus {
+	struct device *dev;
+	const struct i2s_bus_ops *ops;
+	const struct i2s_io_ops *io_ops;
+	const struct i2s_ext_bus_ops *ext_ops;
+
+	/* h/w resources */
+	unsigned long addr;
+	void __iomem *remap_addr;
+	int irq;
+
+	/* codec linked list */
+	struct list_head codec_list;
+	unsigned int num_codecs;
+
+	unsigned int unsol_rp, unsol_wp;
+	struct work_struct unsol_work;
+
+	struct snd_dma_buffer bdl0;
+	struct snd_dma_buffer bdl1;
+
+	/* i2s_stream linked list */
+	struct list_head stream_list;
+
+	bool reverse_assign;		/* assign devices in reverse order */
+
+	int bdl_pos_adj;		/* BDL position adjustment */
+
+	/* locks */
+	spinlock_t reg_lock;
+};
+
+struct i2s_bus {
+	struct i2sc_bus core;
+
+	struct snd_card *card;
+
+	struct pci_dev *pci;
+
+	struct mutex prepare_mutex;
+};
+
+
+/*
+ * i2s stream
+ */
+struct i2s_stream {
+	struct i2sc_bus *bus;
+	struct snd_dma_buffer bdl; /* BDL buffer */
+	__le32 *posbuf;		/* position buffer pointer */
+	int direction;		/* playback / capture (SNDRV_PCM_STREAM_*) */
+
+	unsigned int bufsize;	/* size of the play buffer in bytes */
+	unsigned int period_bytes; /* size of the period in bytes */
+	unsigned int frags;	/* number for period in the play buffer */
+	unsigned int fifo_size;	/* FIFO size */
+
+	void __iomem *sd_addr;	/* stream descriptor pointer */
+
+	u32 sd_int_sta_mask;	/* stream int status mask */
+
+	/* pcm support */
+	struct snd_pcm_substream *substream;	/* assigned substream,
+						 * set in PCM open
+						 */
+	unsigned int format_val;	/* format value to be set in the
+					 * controller and the codec
+					 */
+	unsigned char stream_tag;	/* assigned stream */
+	unsigned char index;		/* stream index */
+	int assigned_key;		/* last device# key assigned to */
+
+	bool opened;
+	bool running;
+	bool prepared;
+	bool no_period_wakeup;
+
+	int delay_negative_threshold;
+
+	struct list_head list;
+
+};
+
+
+struct azx_dev {
+	struct i2s_stream core;
+	unsigned int irq_pending:1;
+};
+
+
+
+/* PCM setup */
+static inline struct azx_dev *get_azx_dev(struct snd_pcm_substream *substream)
+{
+	return substream->runtime->private_data;
+}
+
+
+#define AZX_MAX_CODECS		HDA_MAX_CODECS
+#define AZX_DEFAULT_CODECS	4
+
+#define stream_to_azx_dev(s)	container_of(s, struct azx_dev, core)
+
+struct azx;
+
+struct i2s_controller_ops {
+	int (*substream_alloc_pages)(struct azx *chip,
+				     struct snd_pcm_substream *substream,
+				     size_t size);
+	int (*substream_free_pages)(struct azx *chip,
+				    struct snd_pcm_substream *substream);
+	int (*position_check)(struct azx *chip, struct azx_dev *azx_dev);
+};
+
+struct i2s_io_ops {
+	int (*dma_alloc_pages)(struct i2sc_bus *bus, int type, size_t size,
+			       struct snd_dma_buffer *buf);
+	void (*dma_free_pages)(struct i2sc_bus *bus,
+			       struct snd_dma_buffer *buf);
+};
+
+struct azx {
+	struct i2s_bus bus;
+
+	struct snd_card *card;
+	struct pci_dev *pci;
+	int dev_index;
+
+	int playback_streams;
+	int playback_index_offset;
+	int capture_streams;
+	int capture_index_offset;
+	int num_streams;
+
+	/* Register interaction. */
+	const struct i2s_controller_ops *ops;
+
+	/* locks */
+	struct mutex open_mutex; /* Prevents concurrent open/close operations */
+
+	/* PCM */
+	struct list_head pcm_list; /* azx_pcm list */
+
+	/* flags */
+	int bdl_pos_adj;
+	unsigned int running:1;
+	unsigned int region_requested:1;
+	unsigned int disabled:1;
+};
+struct i2s_phytium {
+	struct azx chip;
+	struct snd_pcm_substream *substream;
+	struct device *dev;
+	struct device *pdev;
+	void __iomem *regs;
+	void __iomem *regs_db;
+	int irq_id;
+
+	/* for pending irqs */
+	struct work_struct irq_pending_work;
+
+	/* sync probing */
+	struct completion probe_wait;
+	struct work_struct probe_work;
+
+	/* extra flags */
+	unsigned int irq_pending_warned:1;
+	unsigned int probe_continued:1;
+	unsigned int i2s_dp:1;
+
+	unsigned int i2s_reg_comp1;
+	unsigned int i2s_reg_comp2;
+	struct clk *clk;
+	unsigned int capability;
+	unsigned int quirks;
+	u32 fifo_th;
+	int active;
+	u32 xfer_resolution;
+	u32 ccr;
+	u32 clk_base;
+
+	struct i2s_clk_config_data config;
+
+	  /*azx_dev*/
+	struct i2s_stream core;
+};
+
+#define azx_alloc_stream_pages(chip) \
+	snd_i2s_bus_alloc_stream_pages(azx_bus(chip))
+
+#endif
diff --git a/sound/soc/phytium/phytium_i2s.c b/sound/soc/phytium/phytium_i2s.c
new file mode 100644
index 000000000000..9c6ab16d83f7
--- /dev/null
+++ b/sound/soc/phytium/phytium_i2s.c
@@ -0,0 +1,1345 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Phytium I2S ASoc driver
+ *
+ * Copyright (C) 2020-2021, Phytium Technology Co.,Ltd.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <sound/designware_i2s.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/clocksource.h>
+#include <linux/random.h>
+#include <linux/timecounter.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <linux/pci.h>
+#include "local.h"
+
+/* FT have 1 playback and 1 capture */
+#define FT4C_NUM_CAPTURE	1
+#define FT4C_NUM_PLAYBACK	1
+
+struct pdata_x100_mfd {
+	struct device		*dev;
+	char *name;
+	int clk_base;
+};
+
+static inline void i2s_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 i2s_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static inline void i2s_disable_channels(struct i2s_phytium *dev, u32 stream)
+{
+	u32 i = 0;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < 4; i++)
+			i2s_write_reg(dev->regs, TER(i), 0);
+	} else {
+		for (i = 0; i < 4; i++)
+			i2s_write_reg(dev->regs, RER(i), 0);
+	}
+}
+
+static int substream_free_pages(struct azx *chip,
+				struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static void stream_update(struct i2sc_bus *bus, struct i2s_stream *s)
+{
+	struct azx *chip = bus_to_azx(bus);
+
+	struct azx_dev *azx_dev = stream_to_azx_dev(s);
+
+	/* check whether this IRQ is really acceptable */
+	if (!chip->ops->position_check ||
+	    chip->ops->position_check(chip, azx_dev)) {
+		spin_unlock(&bus->reg_lock);
+		snd_pcm_period_elapsed(azx_stream(azx_dev)->substream);
+		spin_lock(&bus->reg_lock);
+	}
+
+}
+
+int snd_i2s_bus_handle_stream_irq(struct i2sc_bus *bus, unsigned int status,
+				    void (*ack)(struct i2sc_bus *,
+						struct i2s_stream *))
+{
+	struct i2s_stream *azx_dev;
+	u32 sd_status, qc_sd_status;
+	int handled = 0;
+
+	list_for_each_entry(azx_dev, &bus->stream_list, list) {
+
+		if (status & azx_dev->sd_int_sta_mask) {
+			sd_status = i2s_read_reg(azx_dev->sd_addr, DMA_STS);
+			i2s_write_reg(azx_dev->sd_addr, DMA_STS, azx_dev->sd_int_sta_mask);
+			qc_sd_status = i2s_read_reg(azx_dev->sd_addr, DMA_STS);
+			handled |= 1 << azx_dev->index;
+			azx_dev->running = 1;
+			if (!azx_dev->substream || !azx_dev->running ||
+			    !(sd_status & 0xffffffff)) {
+				continue;
+			}
+			if (ack)
+				ack(bus, azx_dev);
+		}
+	}
+	return handled;
+}
+
+irqreturn_t azx_i2s_interrupt(int irq, void *dev_id)
+{
+	struct azx *chip = dev_id;
+	struct i2sc_bus *bus = azx_bus(chip);
+	u32 status;
+	bool active, handled = false;
+	int repeat = 0; /* count for avoiding endless loop */
+
+	spin_lock(&bus->reg_lock);
+
+	if (chip->disabled)
+		goto unlock;
+
+	do {
+
+		status = i2s_read_reg(bus->remap_addr, DMA_STS);
+
+		if (status == 0)
+			break;
+
+		handled = true;
+		active = false;
+		if (snd_i2s_bus_handle_stream_irq(bus, status, stream_update))
+			active = true;
+
+
+	} while (active && ++repeat < 1);
+
+ unlock:
+	spin_unlock(&bus->reg_lock);
+
+	return IRQ_RETVAL(handled);
+}
+
+static int azx_acquire_irq(struct azx *chip, int do_disconnect)
+{
+	struct i2sc_bus *bus = azx_bus(chip);
+	struct i2s_phytium *i2s = container_of(chip, struct i2s_phytium, chip);
+	int err;
+
+	err = devm_request_irq(i2s->dev, i2s->irq_id, azx_i2s_interrupt, IRQF_SHARED,
+				"phytium i2s", chip);
+
+	if (err < 0) {
+		dev_err(i2s->dev, "failed to request irq\n");
+		return err;
+	}
+
+	bus->irq = i2s->irq_id;
+
+	return 0;
+}
+
+static void i2s_start(struct i2s_phytium *dev,
+		      struct snd_pcm_substream *substream)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->regs, ITER, 1);
+	else
+		i2s_write_reg(dev->regs, IRER, 1);
+
+	/*enable the clock*/
+	i2s_write_reg(dev->regs, CER, 1);
+
+	/*enable the i2s*/
+	i2s_write_reg(dev->regs, I2S_IER, 1);
+}
+
+static void i2s_stop(struct i2s_phytium *dev,
+		struct snd_pcm_substream *substream)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->regs, ITER, 0);
+	else
+		i2s_write_reg(dev->regs, IRER, 0);
+
+	if (!dev->active) {
+		i2s_write_reg(dev->regs, CER, 0);
+		i2s_write_reg(dev->regs, I2S_IER, 0);
+	}
+}
+
+static void dw_i2s_config(struct i2s_phytium *dev, int stream)
+{
+	i2s_disable_channels(dev, stream);
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		i2s_write_reg(dev->regs, TCR(0), dev->xfer_resolution);
+		i2s_write_reg(dev->regs, TER(0), 1);
+	} else {
+		i2s_write_reg(dev->regs, RCR(0), dev->xfer_resolution);
+		i2s_write_reg(dev->regs, RER(0), 1);
+	}
+}
+
+static int dw_i2s_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct i2s_phytium *dev = snd_soc_dai_get_drvdata(dai);
+	struct i2s_clk_config_data *config = &dev->config;
+	u64 fix, point;
+	u32 cfg = 0;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		config->data_width = 16;
+		dev->ccr = 0x00;
+		dev->xfer_resolution = 0x02;
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		config->data_width = 24;
+		dev->ccr = 0x08;
+		dev->xfer_resolution = 0x04;
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		config->data_width = 32;
+		dev->ccr = 0x10;
+		dev->xfer_resolution = 0x05;
+		break;
+
+	default:
+		dev_err(dev->dev, "phytium-i2s: unsupported PCM fmt");
+		return -EINVAL;
+	}
+
+	config->chan_nr = params_channels(params);
+
+	switch (config->chan_nr) {
+	case EIGHT_CHANNEL_SUPPORT:
+	case SIX_CHANNEL_SUPPORT:
+	case FOUR_CHANNEL_SUPPORT:
+	case TWO_CHANNEL_SUPPORT:
+		break;
+	default:
+		dev_err(dev->dev, "channel not supported\n");
+		return -EINVAL;
+	}
+
+	dw_i2s_config(dev, substream->stream);
+
+	i2s_write_reg(dev->regs, CCR, dev->ccr);
+
+	config->sample_rate = params_rate(params);
+	if (dev->capability & DW_I2S_MASTER) {
+		fix = dev->clk_base / config->sample_rate / config->data_width / 32;
+		point = ((dev->clk_base / config->sample_rate) << 10) / config->data_width / 32;
+		point = (point - (fix << 10)) * 10;
+		cfg = ((u16) fix << 16) | (u16) point;
+		i2s_write_reg(dev->regs, CLK_CFG0, cfg);
+		i2s_write_reg(dev->regs, CLK_CFG1, 0xf);
+	}
+	return 0;
+}
+
+static int dw_i2s_prepare(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *dai)
+{
+	struct i2s_phytium *dev = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->regs, TXFFR, 1);
+	else
+		i2s_write_reg(dev->regs, RXFFR, 1);
+
+	return 0;
+}
+
+static int dw_i2s_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct i2s_phytium *dev = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dev->active++;
+		i2s_start(dev, substream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev->active--;
+		i2s_stop(dev, substream);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int dw_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct i2s_phytium *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		if (dev->capability & DW_I2S_SLAVE)
+			ret = 0;
+		else
+			ret = -EINVAL;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		if (dev->capability & DW_I2S_MASTER)
+			ret = 0;
+		else
+			ret = -EINVAL;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+	case SND_SOC_DAIFMT_CBS_CFM:
+		ret = -EINVAL;
+		break;
+	default:
+		dev_dbg(dev->dev, "phytium/i2s: Invalid master/slave format\n");
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static const struct snd_soc_dai_ops phytium_i2s_dai_ops = {
+	.hw_params	= dw_i2s_hw_params,
+	.prepare	= dw_i2s_prepare,
+	.trigger	= dw_i2s_trigger,
+	.set_fmt	= dw_i2s_set_fmt,
+};
+
+#ifdef CONFIG_PM
+static int phytium_i2s_suspend(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int phytium_i2s_resume(struct snd_soc_dai *dai)
+{
+	struct i2s_phytium *dev = snd_soc_dai_get_drvdata(dai);
+	if (dai->playback_active)
+		dw_i2s_config(dev, SNDRV_PCM_STREAM_PLAYBACK);
+	if (dai->capture_active)
+		dw_i2s_config(dev, SNDRV_PCM_STREAM_CAPTURE);
+	return 0;
+}
+#else
+#define phytium_i2s_suspend NULL
+#define phytium_i2s_resume  NULL
+#endif
+
+static struct snd_soc_dai_driver phytium_i2s_dai = {
+	.playback = {
+		.stream_name = "i2s-Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S8 |
+			   SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_S20_LE |
+			   SNDRV_PCM_FMTBIT_S24_LE |
+			   SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.stream_name = "i2s-Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S8 |
+			   SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_S20_LE |
+			   SNDRV_PCM_FMTBIT_S24_LE |
+			   SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops     = &phytium_i2s_dai_ops,
+	.suspend = phytium_i2s_suspend,
+	.resume  = phytium_i2s_resume,
+	.symmetric_rates = 1,
+};
+
+static const struct snd_pcm_hardware phytium_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER,
+	.rates = SNDRV_PCM_RATE_8000 |
+		SNDRV_PCM_RATE_32000 |
+		SNDRV_PCM_RATE_44100 |
+		SNDRV_PCM_RATE_48000,
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.formats = (SNDRV_PCM_FMTBIT_S8 |
+		SNDRV_PCM_FMTBIT_S16_LE |
+		SNDRV_PCM_FMTBIT_S20_LE |
+		SNDRV_PCM_FMTBIT_S24_LE |
+		SNDRV_PCM_FMTBIT_S32_LE),
+	.channels_min = 2,
+	.channels_max = 2,
+	.buffer_bytes_max = 4096*16,
+	.period_bytes_min = 1024,
+	.period_bytes_max = 4096*4,
+	.periods_min = 2,
+	.periods_max = 16,
+	.fifo_size = 16,
+};
+
+struct i2s_stream *snd_i2s_stream_assign(struct i2sc_bus *bus,
+					   struct snd_pcm_substream *substream)
+{
+	struct i2s_stream *azx_dev;
+	struct i2s_stream *res = NULL;
+
+	/* make a non-zero unique key for the substream */
+	int key = (substream->pcm->device << 16) | (substream->number << 2) |
+		(substream->stream + 1);
+
+	list_for_each_entry(azx_dev, &bus->stream_list, list) {
+		if (azx_dev->direction != substream->stream)
+			continue;
+
+		azx_dev->opened = 0;
+
+		if (azx_dev->assigned_key == key) {
+			res = azx_dev;
+			break;
+		}
+
+		if (!res || bus->reverse_assign)
+			res = azx_dev;
+	}
+
+	if (res) {
+		spin_lock_irq(&bus->reg_lock);
+		res->opened = 1;
+		res->running = 0;
+		res->assigned_key = key;
+		res->substream = substream;
+		spin_unlock_irq(&bus->reg_lock);
+	}
+
+	return res;
+}
+
+/* assign a stream for the PCM */
+static inline struct azx_dev *
+azx_assign_device(struct azx *chip, struct snd_pcm_substream *substream)
+{
+	struct i2s_stream *s;
+
+	s = snd_i2s_stream_assign(azx_bus(chip), substream);
+	if (!s)
+		return NULL;
+	return stream_to_azx_dev(s);
+}
+
+static int phytium_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct i2s_phytium *dev = snd_soc_dai_get_drvdata(rtd->cpu_dai);
+
+	struct azx *chip = &dev->chip;
+	struct azx_dev *azx_dev;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	azx_dev = azx_assign_device(chip, substream);
+	if (azx_dev == NULL)
+		return -EBUSY;
+
+	snd_soc_set_runtime_hwparams(substream, &phytium_pcm_hardware);
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	runtime->private_data = dev;
+
+	return 0;
+}
+
+static int phytium_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct i2s_phytium *dev = snd_soc_dai_get_drvdata(rtd->cpu_dai);
+	struct azx *chip = &dev->chip;
+	struct azx_dev *azx_dev = get_azx_dev(substream);
+
+	mutex_lock(&chip->open_mutex);
+	azx_stream(azx_dev)->opened = 0;
+	azx_stream(azx_dev)->running = 0;
+	azx_stream(azx_dev)->substream = NULL;
+
+	mutex_unlock(&chip->open_mutex);
+	return 0;
+}
+
+static int phytium_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct i2s_phytium *i2s = snd_soc_dai_get_drvdata(rtd->cpu_dai);
+	size_t size = phytium_pcm_hardware.buffer_bytes_max;
+
+	return snd_pcm_lib_preallocate_pages_for_all(rtd->pcm,
+			SNDRV_DMA_TYPE_DEV,
+			i2s->pdev, size, size);
+}
+
+static const struct i2s_io_ops axi_i2s_io_ops;
+static const struct i2s_controller_ops axi_i2s_ops;
+
+static int phytium_pcm_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct i2s_phytium *dev = runtime->private_data;
+	struct azx *chip = &dev->chip;
+	struct azx_dev *azx_dev = get_azx_dev(substream);
+	int ret;
+
+	azx_dev->core.bufsize = 0;
+	azx_dev->core.period_bytes = 0;
+	azx_dev->core.format_val = 0;
+
+	ret = chip->ops->substream_alloc_pages(chip, substream,
+					  params_buffer_bytes(hw_params));
+
+	return ret;
+}
+/*
+ * set up a BDL entry
+ */
+static int setup_bdle(struct i2sc_bus *bus,
+		      struct snd_dma_buffer *dmab,
+		      struct i2s_stream *azx_dev, __le32 **bdlp,
+		      int ofs, int size, int with_ioc)
+{
+	struct snd_pcm_substream *substream = azx_dev->substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	__le32 *bdl = *bdlp;
+
+	dmab->addr = runtime->dma_addr;
+	while (size > 0) {
+		dma_addr_t addr;
+		int chunk;
+
+		if (azx_dev->frags >= AZX_MAX_BDL_ENTRIES)
+			return -EINVAL;
+
+		addr = snd_sgbuf_get_addr(dmab, ofs);
+
+		/* program the address field of the BDL entry */
+		bdl[0] = cpu_to_le32((u32)addr);
+
+		bdl[1] = cpu_to_le32(upper_32_bits(addr));
+
+		/* program the size field of the BDL entry */
+		chunk = snd_sgbuf_get_chunk_size(dmab, ofs, size);
+
+		bdl[2] = cpu_to_le32(chunk);
+
+		/* program the IOC to enable interrupt
+		 * only when the whole fragment is processed
+		 */
+		size -= chunk;
+		bdl[3] = (size || !with_ioc) ? 0 : cpu_to_le32(0x01);
+
+		bdl += 4;
+		azx_dev->frags++;
+		ofs += chunk;
+	}
+	*bdlp = bdl;
+	return ofs;
+}
+
+int snd_i2s_stream_setup_periods(struct i2s_stream *azx_dev)
+{
+	struct i2sc_bus *bus = azx_dev->bus;
+	struct snd_pcm_substream *substream = azx_dev->substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	__le32 *bdl;
+	int i, ofs, periods, period_bytes;
+	int pos_adj, pos_align;
+
+	period_bytes = azx_dev->period_bytes;
+	periods = azx_dev->bufsize / period_bytes;
+
+	/* program the initial BDL entries */
+	bdl = (__le32 *)azx_dev->bdl.area;
+
+	ofs = 0;
+	azx_dev->frags = 0;
+
+	pos_adj = bus->bdl_pos_adj;
+
+	if (!azx_dev->no_period_wakeup && pos_adj > 0) {
+
+		pos_align = pos_adj;
+		pos_adj = (pos_adj * runtime->rate + 47999) / 48000;
+		if (!pos_adj)
+			pos_adj = pos_align;
+		else
+			pos_adj = ((pos_adj + pos_align - 1) / pos_align) *
+				pos_align;
+		pos_adj = frames_to_bytes(runtime, pos_adj);
+		if (pos_adj >= period_bytes) {
+			dev_warn(bus->dev, "Too big adjustment %d\n",
+				 pos_adj);
+			pos_adj = 0;
+		} else {
+
+			ofs = setup_bdle(bus, snd_pcm_get_dma_buf(substream),
+					 azx_dev,
+					 &bdl, ofs, pos_adj, true);
+			if (ofs < 0)
+				goto error;
+		}
+	} else
+		pos_adj = 0;
+
+	for (i = 0; i < periods; i++) {
+		if (i == periods - 1 && pos_adj)
+			ofs = setup_bdle(bus, snd_pcm_get_dma_buf(substream),
+					 azx_dev, &bdl, ofs,
+					 period_bytes - pos_adj, 0);
+		else
+			ofs = setup_bdle(bus, snd_pcm_get_dma_buf(substream),
+					 azx_dev, &bdl, ofs,
+					 period_bytes,
+					 !azx_dev->no_period_wakeup);
+		if (ofs < 0)
+			goto error;
+	}
+	return 0;
+
+ error:
+	dev_err(bus->dev, "Too many BDL entries: buffer=%d, period=%d\n",
+		azx_dev->bufsize, period_bytes);
+	return -EINVAL;
+}
+
+int snd_i2s_stream_set_params(struct i2s_stream *azx_dev,
+				 unsigned int format_val)
+{
+	unsigned int bufsize, period_bytes;
+	struct snd_pcm_substream *substream = azx_dev->substream;
+	struct snd_pcm_runtime *runtime;
+	int err;
+
+	if (!substream)
+		return -EINVAL;
+
+	runtime = substream->runtime;
+	bufsize = snd_pcm_lib_buffer_bytes(substream);
+	period_bytes = snd_pcm_lib_period_bytes(substream);
+	if (bufsize != azx_dev->bufsize ||
+	    period_bytes != azx_dev->period_bytes ||
+	    format_val != azx_dev->format_val ||
+	    runtime->no_period_wakeup != azx_dev->no_period_wakeup) {
+
+		azx_dev->bufsize = bufsize;
+		azx_dev->period_bytes = period_bytes;
+		azx_dev->format_val = format_val;
+		azx_dev->no_period_wakeup = runtime->no_period_wakeup;
+		err = snd_i2s_stream_setup_periods(azx_dev);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+int snd_i2s_stream_setup(struct i2s_stream *azx_dev)
+{
+	struct snd_pcm_runtime *runtime;
+
+	if (azx_dev->substream)
+		runtime = azx_dev->substream->runtime;
+	else
+		runtime = NULL;
+
+	i2s_write_reg(azx_dev->sd_addr, DMA_CHAL_CONFG0, 0x8180);
+	i2s_write_reg(azx_dev->sd_addr, DMA_MASK_INT, 0x80000003);
+
+	if (azx_dev->direction == SNDRV_PCM_STREAM_PLAYBACK) {
+		i2s_write_reg(azx_dev->sd_addr, DMA_BDLPL(0), (u32)azx_dev->bdl.addr);
+		i2s_write_reg(azx_dev->sd_addr, DMA_BDLPU(0), upper_32_bits(azx_dev->bdl.addr));
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_DEV_ADDR(0), 0x1c8);
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CBL(0), azx_dev->bufsize);
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_LVI(0), azx_dev->frags - 1);
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_DSIZE(0), 0x2);//0x2
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_DLENTH(0), 0x0);//0x0
+	} else {
+		i2s_write_reg(azx_dev->sd_addr, DMA_BDLPL(1), (u32)azx_dev->bdl.addr);
+		i2s_write_reg(azx_dev->sd_addr, DMA_BDLPU(1), upper_32_bits(azx_dev->bdl.addr));
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_DEV_ADDR(1), 0x1c0);
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CBL(1), azx_dev->bufsize);
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_LVI(1), azx_dev->frags - 1);
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_DSIZE(1), 0x8);//0x8
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_DLENTH(1), 0x0);
+	}
+
+	if (runtime && runtime->period_size > 64)
+		azx_dev->delay_negative_threshold =
+			-frames_to_bytes(runtime, 64);
+	else
+		azx_dev->delay_negative_threshold = 0;
+
+	return 0;
+}
+
+static int phytium_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct i2s_phytium *dev = runtime->private_data;
+	struct azx *chip = &dev->chip;
+	struct azx_dev *azx_dev = get_azx_dev(substream);
+	struct i2sc_bus *bus = azx_bus(chip);
+	struct i2s_stream *hstr_p;
+	struct i2s_phytium *i2s = runtime->private_data;
+	int err;
+
+	i2s->substream = substream;
+	azx_dev->core.substream = substream;
+	azx_dev->core.sd_addr = i2s->regs_db;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		azx_dev->core.bdl.area = bus->bdl0.area;
+		azx_dev->core.bdl.addr = bus->bdl0.addr;
+	} else {
+		azx_dev->core.bdl.area = bus->bdl1.area;
+		azx_dev->core.bdl.addr = bus->bdl1.addr;
+	}
+
+	if (!substream)
+		return -EINVAL;
+
+	hstr_p = azx_stream(azx_dev);
+	hstr_p->direction = substream->stream;
+
+	err = snd_i2s_stream_set_params(azx_stream(azx_dev), 0);
+	if (err < 0)
+		goto unlock;
+
+	snd_i2s_stream_setup(azx_stream(azx_dev));
+
+ unlock:
+	if (!err)
+		azx_stream(azx_dev)->prepared = 1;
+
+	return err;
+}
+
+void snd_i2s_stream_clear(struct i2s_stream *azx_dev)
+{
+	if (azx_dev->direction == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CTL(0), 0x0);
+	else
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CTL(1), 0x0);
+
+	azx_dev->running = false;
+}
+
+void snd_i2s_stream_stop(struct i2s_stream *azx_dev)
+{
+	snd_i2s_stream_clear(azx_dev);
+}
+
+void snd_i2s_stream_start(struct i2s_stream *azx_dev, bool fresh_start)
+{
+	if (azx_dev->direction == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CTL(0), 0x1);
+	else
+		i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CTL(1), 0x5);
+
+	azx_dev->running = true;
+}
+
+static int phytium_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct i2s_phytium *dev = runtime->private_data;
+	struct azx *chip = &dev->chip;
+	struct i2sc_bus *bus = azx_bus(chip);
+	struct azx_dev *azx_dev = get_azx_dev(substream);
+	struct snd_pcm_substream *s;
+	struct i2s_stream *hstr;
+	bool start;
+	int sbits = 0;
+
+	hstr = azx_stream(azx_dev);
+	hstr->direction = substream->stream;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		start = true;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+		start = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snd_pcm_group_for_each_entry(s, substream) {
+		if (s->pcm->card != substream->pcm->card)
+			continue;
+		azx_dev = get_azx_dev(s);
+		sbits |= 1 << azx_dev->core.index;
+		snd_pcm_trigger_done(s, substream);
+	}
+
+	spin_lock(&bus->reg_lock);
+
+	snd_pcm_group_for_each_entry(s, substream) {
+		if (s->pcm->card != substream->pcm->card)
+			continue;
+		azx_dev = get_azx_dev(s);
+		if (start)
+			snd_i2s_stream_start(azx_stream(azx_dev), true);
+		else
+			snd_i2s_stream_stop(azx_stream(azx_dev));
+	}
+
+	i2s_write_reg(dev->regs_db, DMA_CTL, 0x1);
+	spin_unlock(&bus->reg_lock);
+
+	return 0;
+}
+
+static void phytium_pcm_free(struct snd_pcm *pcm)
+{
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+void snd_i2s_stream_cleanup(struct i2s_stream *azx_dev)
+{
+	int cnt = 10;
+	if (azx_dev->sd_addr) {
+		if (azx_dev->direction == SNDRV_PCM_STREAM_PLAYBACK) {
+			i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CTL(0), 0);
+			while (cnt--) {
+				if (i2s_read_reg(azx_dev->sd_addr, DMA_CHALX_CTL(0)) == 0)
+					break;
+			}
+			i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CTL(0), 2);
+			i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CTL(0), 0);
+			i2s_write_reg(azx_dev->sd_addr, DMA_BDLPL(0), 0);
+			i2s_write_reg(azx_dev->sd_addr, DMA_BDLPU(0), 0);
+		} else {
+			i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CTL(1), 0);
+			while (cnt--) {
+				if (i2s_read_reg(azx_dev->sd_addr, DMA_CHALX_CTL(1)) == 0)
+					break;
+			}
+			i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CTL(1), 2);
+			i2s_write_reg(azx_dev->sd_addr, DMA_CHALX_CTL(1), 0);
+			i2s_write_reg(azx_dev->sd_addr, DMA_BDLPL(1), 0);
+			i2s_write_reg(azx_dev->sd_addr, DMA_BDLPU(1), 0);
+		}
+	}
+}
+
+static int phytium_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct i2s_phytium *dev = runtime->private_data;
+	struct azx *chip = &dev->chip;
+	struct i2s_stream *hstr_p;
+	struct azx_dev *azx_dev = get_azx_dev(substream);
+	int err;
+
+	hstr_p = azx_stream(azx_dev);
+	hstr_p->direction = substream->stream;
+	snd_i2s_stream_cleanup(azx_stream(azx_dev));
+
+	err = chip->ops->substream_free_pages(chip, substream);
+	azx_stream(azx_dev)->prepared = 0;
+
+	return err;
+}
+
+static snd_pcm_uframes_t phytium_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct i2s_phytium *dev = runtime->private_data;
+
+	int stream = substream->stream;
+
+	u32 pos = i2s_read_reg(dev->regs_db, DMA_LPIB(stream));
+
+	return bytes_to_frames(substream->runtime, pos);
+}
+
+static const struct snd_pcm_ops phytium_pcm_ops = {
+	.open = phytium_pcm_open,
+	.close = phytium_pcm_close,
+	.hw_params = phytium_pcm_hw_params,
+	.prepare = phytium_pcm_prepare,
+	.hw_free = phytium_pcm_hw_free,
+	.trigger = phytium_pcm_trigger,
+	.pointer = phytium_pcm_pointer,
+};
+
+static const struct snd_soc_component_driver phytium_i2s_component = {
+	.name		= "phytium-i2s",
+	.pcm_new = phytium_pcm_new,
+	.pcm_free = phytium_pcm_free,
+	.ops = &phytium_pcm_ops,
+};
+
+/* Maximum bit resolution of a channel - not uniformly spaced */
+static const u32 fifo_width[COMP_MAX_WORDSIZE] = {
+	12, 16, 20, 24, 32, 0, 0, 0
+};
+
+/* Width of (DMA) bus */
+static const u32 bus_widths[COMP_MAX_DATA_WIDTH] = {
+	DMA_SLAVE_BUSWIDTH_1_BYTE,
+	DMA_SLAVE_BUSWIDTH_2_BYTES,
+	DMA_SLAVE_BUSWIDTH_4_BYTES,
+	DMA_SLAVE_BUSWIDTH_UNDEFINED
+};
+
+/* PCM format to support channel resolution */
+static const u32 formats[COMP_MAX_WORDSIZE] = {
+	SNDRV_PCM_FMTBIT_S16_LE,
+	SNDRV_PCM_FMTBIT_S16_LE,
+	SNDRV_PCM_FMTBIT_S24_LE,
+	SNDRV_PCM_FMTBIT_S24_LE,
+	SNDRV_PCM_FMTBIT_S32_LE,
+	0,
+	0,
+	0
+};
+
+static int phytium_configure_dai(struct i2s_phytium *dev)
+{
+	u32 comp1 = i2s_read_reg(dev->regs, dev->i2s_reg_comp1);
+	u32 comp2 = i2s_read_reg(dev->regs, dev->i2s_reg_comp2);
+	u32 fifo_depth = 1 << (1 + COMP1_FIFO_DEPTH_GLOBAL(comp1));
+	u32 idx;
+
+	if (COMP1_TX_ENABLED(comp1)) {
+		dev_dbg(dev->dev, " phytium: play supported\n");
+		idx = COMP1_TX_WORDSIZE_0(comp1);
+		if (WARN_ON(idx >= ARRAY_SIZE(formats)))
+			return -EINVAL;
+	}
+
+	if (COMP1_RX_ENABLED(comp1)) {
+		dev_dbg(dev->dev, "phytium: record supported\n");
+		idx = COMP2_RX_WORDSIZE_0(comp2);
+		if (WARN_ON(idx >= ARRAY_SIZE(formats)))
+			return -EINVAL;
+		if (dev->quirks & DW_I2S_QUIRK_16BIT_IDX_OVERRIDE)
+			idx = 1;
+	}
+
+	if (COMP1_MODE_EN(comp1)) {
+		dev_dbg(dev->dev, "phytium: i2s master mode supported\n");
+		dev->capability |= DW_I2S_MASTER;
+	} else {
+		dev_dbg(dev->dev, "phytium: i2s slave mode supported\n");
+		dev->capability |= DW_I2S_SLAVE;
+	}
+
+	dev->fifo_th = fifo_depth / 2;
+	return 0;
+}
+
+static int phytium_configure_dai_by_dt(struct i2s_phytium *dev)
+{
+	u32 comp1 = i2s_read_reg(dev->regs, I2S_COMP_PARAM_1);
+	u32 comp2 = i2s_read_reg(dev->regs, I2S_COMP_PARAM_2);
+	u32 idx = COMP1_APB_DATA_WIDTH(comp1);
+	u32 idx2;
+	int ret;
+
+	if (WARN_ON(idx >= ARRAY_SIZE(bus_widths)))
+		return -EINVAL;
+
+	ret = phytium_configure_dai(dev);
+	if (ret < 0)
+		return ret;
+
+	if (COMP1_TX_ENABLED(comp1)) {
+		idx2 = COMP1_TX_WORDSIZE_0(comp1);
+		dev->capability |= DWC_I2S_PLAY;
+	}
+	if (COMP1_RX_ENABLED(comp1)) {
+		idx2 = COMP2_RX_WORDSIZE_0(comp2);
+		dev->capability |= DWC_I2S_RECORD;
+	}
+
+	return 0;
+}
+
+static int dma_alloc_pages(struct i2sc_bus *bus, int type, size_t size,
+			       struct snd_dma_buffer *buf)
+{
+	int err;
+
+	err = snd_dma_alloc_pages(type, bus->dev, size, buf);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+int snd_i2s_bus_alloc_stream_pages(struct i2sc_bus *bus)
+{
+	struct i2s_stream *s;
+	int num_streams = 0;
+	int err;
+
+	list_for_each_entry(s, &bus->stream_list, list) {
+
+		/* allocate memory for the BDL for each stream */
+		err = bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV,
+						   BDL_SIZE, &s->bdl);
+		if (num_streams == 0) {
+			bus->bdl0.addr = s->bdl.addr;
+			bus->bdl0.area = s->bdl.area;
+		} else {
+			bus->bdl1.addr = s->bdl.addr;
+			bus->bdl1.area = s->bdl.area;
+		}
+		num_streams++;
+		if (err < 0)
+			return -ENOMEM;
+	}
+
+	if (WARN_ON(!num_streams))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int stream_direction(struct azx *chip, unsigned char index)
+{
+	if (index >= chip->playback_index_offset &&
+	    index < chip->playback_index_offset + chip->playback_streams)
+		return SNDRV_PCM_STREAM_PLAYBACK;
+	return SNDRV_PCM_STREAM_CAPTURE;
+
+}
+
+void snd_i2s_stream_init(struct i2sc_bus *bus, struct i2s_stream *azx_dev,
+			  int idx, int direction, int tag)
+{
+	azx_dev->bus = bus;
+	azx_dev->sd_addr = bus->remap_addr;
+
+	if (idx == 0)
+		azx_dev->sd_int_sta_mask = 1 << idx;
+	else
+		azx_dev->sd_int_sta_mask = 1 << 8;
+
+	azx_dev->index = idx;
+	azx_dev->direction = direction;
+	azx_dev->stream_tag = tag;
+
+	list_add_tail(&azx_dev->list, &bus->stream_list);
+
+}
+
+int azx_i2s_init_streams(struct azx *chip)
+{
+	int i;
+
+	for (i = 0; i < chip->num_streams; i++) {
+		struct azx_dev *azx_dev = kzalloc(sizeof(*azx_dev), GFP_KERNEL);
+		int dir, tag;
+
+		if (!azx_dev)
+			return -ENOMEM;
+
+		dir = stream_direction(chip, i);
+
+		tag = i + 1;
+
+		snd_i2s_stream_init(azx_bus(chip), azx_stream(azx_dev),
+				     i, dir, tag);
+	}
+
+	return 0;
+}
+
+static int azx_first_init(struct azx *chip)
+{
+	struct i2s_phytium *i2s = container_of(chip, struct i2s_phytium, chip);
+	struct platform_device *pdev = to_platform_device(i2s->dev);
+	struct device *i2sdev = i2s->dev;
+	struct i2sc_bus *bus = azx_bus(chip);
+	struct resource *res;
+	int err;
+	unsigned int dma_bits = 64;
+
+	chip->region_requested = 1;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	bus->addr = res->start;
+	bus->remap_addr = i2s->regs_db;
+	bus->dev = i2s->pdev;
+
+	if (bus->remap_addr == NULL) {
+		dev_err(i2sdev, "ioremap error\n");
+		return -ENXIO;
+	}
+
+	if (azx_acquire_irq(chip, 0) < 0)
+		return -EBUSY;
+
+	synchronize_irq(bus->irq);
+
+	if (!dma_set_mask(i2sdev, DMA_BIT_MASK(dma_bits))) {
+		err = dma_set_coherent_mask(i2sdev, DMA_BIT_MASK(dma_bits));
+	} else {
+		err = dma_set_mask(i2sdev, DMA_BIT_MASK(32));
+		err = dma_set_coherent_mask(i2sdev, DMA_BIT_MASK(32));
+	}
+
+	chip->playback_streams = FT4C_NUM_PLAYBACK;
+	chip->capture_streams  = FT4C_NUM_CAPTURE;
+
+	chip->playback_index_offset = 0;
+	chip->capture_index_offset = chip->playback_streams;
+	chip->num_streams = chip->playback_streams + chip->capture_streams;
+
+	err = azx_i2s_init_streams(chip);
+	if (err < 0)
+		return err;
+
+	err = azx_alloc_stream_pages(chip);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int azx_probe_continue(struct azx *chip)
+{
+	struct i2s_phytium *i2s = container_of(chip, struct i2s_phytium, chip);
+	int err;
+
+	i2s->probe_continued = 1;
+
+	err = azx_first_init(chip);
+	if (err < 0)
+		goto out_free;
+
+	chip->running = 1;
+
+out_free:
+	return err;
+}
+
+static void azx_probe_work(struct work_struct *work)
+{
+	struct i2s_phytium *i2s = container_of(work, struct i2s_phytium, probe_work);
+
+	azx_probe_continue(&i2s->chip);
+}
+
+int azx_i2s_bus_init(struct azx *chip,
+		 const struct i2s_io_ops *io_ops)
+{
+	struct i2s_bus *bus = &chip->bus;
+
+	bus->core.io_ops = io_ops;
+
+	INIT_LIST_HEAD(&bus->core.stream_list);
+	bus->card = chip->card;
+	mutex_init(&bus->prepare_mutex);
+	bus->pci = chip->pci;
+
+	bus->core.bdl_pos_adj = chip->bdl_pos_adj;
+	return 0;
+}
+
+static int i2s_phytium_create(struct platform_device *pdev,
+			int dev, struct azx **rchip, struct i2s_phytium *i2s)
+{
+	struct azx *chip;
+	int err;
+
+	*rchip = NULL;
+
+	if (!i2s)
+		return -ENOMEM;
+	chip = &i2s->chip;
+
+	mutex_init(&chip->open_mutex);
+
+	chip->ops = &axi_i2s_ops;
+	chip->dev_index = dev;
+
+	INIT_LIST_HEAD(&chip->pcm_list);
+	init_completion(&i2s->probe_wait);
+
+	chip->bdl_pos_adj = 32;
+	err = azx_i2s_bus_init(chip, &axi_i2s_io_ops);
+	if (err < 0) {
+		kfree(i2s);
+		return err;
+	}
+
+	INIT_WORK(&i2s->probe_work, azx_probe_work);
+	*rchip = chip;
+	return 0;
+}
+
+static int substream_alloc_pages(struct azx *chip,
+				 struct snd_pcm_substream *substream,
+				 size_t size)
+{
+	int ret;
+
+	ret = snd_pcm_lib_malloc_pages(substream, size);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void dma_free_pages(struct i2sc_bus *bus,
+			       struct snd_dma_buffer *buf)
+{
+	snd_dma_free_pages(buf);
+}
+
+static const struct i2s_io_ops axi_i2s_io_ops = {
+	.dma_alloc_pages = dma_alloc_pages,
+	.dma_free_pages = dma_free_pages,
+};
+
+static const struct i2s_controller_ops axi_i2s_ops = {
+	.substream_alloc_pages = substream_alloc_pages,
+	.substream_free_pages = substream_free_pages,
+};
+
+
+static int phytium_i2s_probe(struct platform_device *pdev)
+{
+	struct i2s_phytium *i2s;
+	struct azx *chip;
+	struct resource *res;
+	struct pdata_x100_mfd *pdata;
+	struct snd_soc_dai_driver *dai_drv;
+	int err, ret;
+	int card_num = 1;
+	bool schedule_probe;
+
+	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
+	if (!i2s)
+		return -ENOMEM;
+
+	dai_drv = devm_kzalloc(&pdev->dev, sizeof(*dai_drv), GFP_KERNEL);
+	if (!dai_drv)
+		return -ENOMEM;
+	memcpy(dai_drv, &phytium_i2s_dai, sizeof(phytium_i2s_dai));
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	i2s->regs = devm_ioremap_resource(&pdev->dev, res);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	i2s->regs_db = devm_ioremap_resource(&pdev->dev, res);
+
+	if (IS_ERR(i2s->regs))
+		return PTR_ERR(i2s->regs);
+
+	i2s->irq_id = platform_get_irq(pdev, 0);
+
+	if (i2s->irq_id < 0)
+		return i2s->irq_id;
+
+	i2s->i2s_reg_comp1 = I2S_COMP_PARAM_1;
+	i2s->i2s_reg_comp2 = I2S_COMP_PARAM_2;
+
+	ret = phytium_configure_dai_by_dt(i2s);
+	if (ret < 0)
+		return ret;
+
+	err = i2s_phytium_create(pdev, card_num, &chip, i2s);
+	if (err < 0)
+		return err;
+	i2s = container_of(chip, struct i2s_phytium, chip);
+	schedule_probe = !chip->disabled;
+
+	dev_set_drvdata(&pdev->dev, i2s);
+
+	pdata = dev_get_platdata(&pdev->dev);
+	dai_drv->name = pdata->name;
+	i2s->dev = &pdev->dev;
+	i2s->pdev = pdata->dev;
+	i2s->clk_base = pdata->clk_base;
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &phytium_i2s_component,
+						 dai_drv, 1);
+	if (ret != 0)
+		dev_err(&pdev->dev, "not able to register dai\n");
+
+	if (schedule_probe)
+		schedule_work(&i2s->probe_work);
+
+	if (chip->disabled)
+		complete_all(&i2s->probe_wait);
+
+	return 0;
+}
+
+static int phytium_i2s_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver phytium_i2s_driver = {
+	.probe	= phytium_i2s_probe,
+	.remove	= phytium_i2s_remove,
+	.driver	= {
+		.name = "phytium-i2s",
+	},
+};
+
+module_platform_driver(phytium_i2s_driver);
+
+MODULE_DESCRIPTION("Phytium I2S Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Zhang Yiqun <zhangyiqun@phytium.com.cn>");
diff --git a/sound/soc/phytium/pmdk_dp.c b/sound/soc/phytium/pmdk_dp.c
new file mode 100644
index 000000000000..0e5a001e8126
--- /dev/null
+++ b/sound/soc/phytium/pmdk_dp.c
@@ -0,0 +1,227 @@
+/*
+ *  pmdk_dp.c
+ *
+ *  Copyright (c) 2021 Phytium Technology Co. Ltd
+ *  Author: Yiqun Zhang <zhangyiqun@phytium.com.cn>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/jack.h>
+
+struct pmdk_dp_private {
+	struct snd_soc_jack jack0;
+	struct snd_soc_jack jack1;
+	struct snd_soc_jack jack2;
+};
+
+/* PMDK widgets */
+static const struct snd_soc_dapm_widget pmdk_dp_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("DP", NULL),
+};
+
+/* PMDK control */
+static const struct snd_kcontrol_new pmdk_controls[] = {
+	SOC_DAPM_PIN_SWITCH("DP"),
+};
+
+/* PMDK connections */
+static const struct snd_soc_dapm_route pmdk_dp_audio_map[] = {
+	{"DP", NULL, "TX"},
+};
+
+static struct snd_soc_jack_pin dp0_pins[] = {
+	{
+		.pin	= "DP/HDMI 0",
+		.mask	= SND_JACK_LINEOUT,
+	},
+};
+
+static struct snd_soc_jack_pin dp1_pins[] = {
+	{
+		.pin	= "DP/HDMI 1",
+		.mask	= SND_JACK_LINEOUT,
+	},
+};
+
+static struct snd_soc_jack_pin dp2_pins[] = {
+	{
+		.pin	= "DP/HDMI 2",
+		.mask	= SND_JACK_LINEOUT,
+	},
+};
+
+#define SMDK_DAI_FMT (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | \
+	SND_SOC_DAIFMT_CBS_CFS)
+
+static int pmdk_dp0_init(struct snd_soc_pcm_runtime *runtime)
+{
+	struct snd_soc_card *card = runtime->card;
+	struct pmdk_dp_private *priv = snd_soc_card_get_drvdata(card);
+	struct snd_soc_component *component = runtime->codec_dai->component;
+	int ret;
+
+	ret = snd_soc_card_jack_new(card, "DP/HDMI 0",
+				    SND_JACK_LINEOUT,
+				    &priv->jack0, dp0_pins,
+				    ARRAY_SIZE(dp0_pins));
+	if (ret) {
+		dev_err(card->dev, "Jack creation failed %d\n", ret);
+		return ret;
+	}
+	snd_soc_component_set_jack(component, &priv->jack0, NULL);
+	return ret;
+}
+
+static int pmdk_dp1_init(struct snd_soc_pcm_runtime *runtime)
+{
+	struct snd_soc_card *card = runtime->card;
+	struct pmdk_dp_private *priv = snd_soc_card_get_drvdata(card);
+	struct snd_soc_component *component = runtime->codec_dai->component;
+	int ret;
+
+	ret = snd_soc_card_jack_new(card, "DP/HDMI 1",
+				    SND_JACK_LINEOUT,
+				    &priv->jack1, dp1_pins,
+				    ARRAY_SIZE(dp1_pins));
+	if (ret) {
+		dev_err(card->dev, "Jack creation failed %d\n", ret);
+		return ret;
+	}
+	snd_soc_component_set_jack(component, &priv->jack1, NULL);
+	return ret;
+}
+
+static int pmdk_dp2_init(struct snd_soc_pcm_runtime *runtime)
+{
+	struct snd_soc_card *card = runtime->card;
+	struct pmdk_dp_private *priv = snd_soc_card_get_drvdata(card);
+	struct snd_soc_component *component = runtime->codec_dai->component;
+	int ret;
+
+	ret = snd_soc_card_jack_new(card, "DP/HDMI 2",
+				    SND_JACK_LINEOUT,
+				    &priv->jack2, dp2_pins,
+				    ARRAY_SIZE(dp2_pins));
+	if (ret) {
+		dev_err(card->dev, "Jack creation failed %d\n", ret);
+		return ret;
+	}
+	snd_soc_component_set_jack(component, &priv->jack2, NULL);
+	return ret;
+}
+
+static struct snd_soc_dai_link pmdk_dai0 = {
+	.name = "Phytium dp0-audio",
+	.stream_name = "Playback",
+	.cpu_dai_name = "phytium-i2s-dp0",
+	.codec_dai_name = "i2s-hifi",
+	.platform_name = "snd-soc-dummy",
+	.codec_name = "hdmi-audio-codec.0.auto",
+	.dai_fmt = SMDK_DAI_FMT,
+	.init = pmdk_dp0_init,
+};
+
+static struct snd_soc_dai_link pmdk_dai1 = {
+	.name = "Phytium dp1-audio",
+	.stream_name = "Playback",
+	.cpu_dai_name = "phytium-i2s-dp1",
+	.codec_dai_name = "i2s-hifi",
+	.platform_name = "snd-soc-dummy",
+	.codec_name = "hdmi-audio-codec.1.auto",
+	.dai_fmt = SMDK_DAI_FMT,
+	.init = pmdk_dp1_init,
+};
+
+static struct snd_soc_dai_link pmdk_dai2 = {
+	.name = "Phytium dp2-audio",
+	.stream_name = "Playback",
+	.cpu_dai_name = "phytium-i2s-dp2",
+	.codec_dai_name = "i2s-hifi",
+	.platform_name = "snd-soc-dummy",
+	.codec_name = "hdmi-audio-codec.2.auto",
+	.dai_fmt = SMDK_DAI_FMT,
+	.init = pmdk_dp2_init,
+};
+
+static struct snd_soc_card pmdk = {
+	.name = "PMDK-I2S",
+	.owner = THIS_MODULE,
+
+	.dapm_widgets = pmdk_dp_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(pmdk_dp_dapm_widgets),
+	.controls = pmdk_controls,
+	.num_controls = ARRAY_SIZE(pmdk_controls),
+	.dapm_routes = pmdk_dp_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(pmdk_dp_audio_map),
+};
+
+static int pmdk_sound_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &pmdk;
+	struct pmdk_dp_private *priv;
+	struct snd_soc_dai_link *pmdk_dai;
+	int num_dp = 2;
+	card->dev = &pdev->dev;
+	device_property_read_u32(&pdev->dev, "num-dp", &num_dp);
+	pmdk_dai = devm_kzalloc(&pdev->dev, num_dp * sizeof(*pmdk_dai), GFP_KERNEL);
+	if (!pmdk_dai)
+		return -ENOMEM;
+
+	switch (num_dp) {
+	case 1:
+		pmdk_dai[0] = pmdk_dai0;
+		break;
+	case 2:
+		pmdk_dai[0] = pmdk_dai0;
+		pmdk_dai[1] = pmdk_dai1;
+		break;
+	case 3:
+		pmdk_dai[0] = pmdk_dai0;
+		pmdk_dai[1] = pmdk_dai1;
+		pmdk_dai[2] = pmdk_dai2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	card->dai_link = pmdk_dai;
+	card->num_links = num_dp;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	snd_soc_card_set_drvdata(card, priv);
+
+	return devm_snd_soc_register_card(&pdev->dev, card);
+}
+
+static const struct acpi_device_id pmdk_sound_acpi_match[] = {
+	{ "PHYT8006", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, pmdk_sound_acpi_match);
+
+static struct platform_driver pmdk_sound_driver = {
+	.probe = pmdk_sound_probe,
+	.driver = {
+		.name = "pmdk_dp",
+		.acpi_match_table = pmdk_sound_acpi_match,
+#ifdef CONFIG_PM
+		.pm = &snd_soc_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(pmdk_sound_driver);
+
+MODULE_AUTHOR("Zhang Yiqun<zhangyiqun@phytium.com.cn>");
+MODULE_DESCRIPTION("ALSA SoC PMDK DP");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/phytium/pmdk_es8336.c b/sound/soc/phytium/pmdk_es8336.c
new file mode 100644
index 000000000000..56333513fbdf
--- /dev/null
+++ b/sound/soc/phytium/pmdk_es8336.c
@@ -0,0 +1,100 @@
+/*
+ *  pmdk_es8336.c
+ *
+ *  Copyright (c) 2021 Phytium Techonology Co. Ltd
+ *  Author: Zhang Yiqun <zhangyiqun@phytium.com.cn>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+
+/* PMDK widgets */
+static const struct snd_soc_dapm_widget pmdk_es8336_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("HP", NULL),
+	SND_SOC_DAPM_MIC("Int Mic", NULL),
+	SND_SOC_DAPM_MIC("Mic In", NULL),
+};
+
+/* PMDK control */
+static const struct snd_kcontrol_new pmdk_controls[] = {
+	SOC_DAPM_PIN_SWITCH("HP"),
+	SOC_DAPM_PIN_SWITCH("Int Mic"),
+	SOC_DAPM_PIN_SWITCH("Mic In"),
+};
+
+/* PMDK connections */
+static const struct snd_soc_dapm_route pmdk_es8336_audio_map[] = {
+	{"DMIC", NULL, "Int Mic"},
+	{"MIC1", NULL, "Mic In"},
+	{"MIC2", NULL, "Mic In"},
+
+	{"HP", NULL, "HPOL"},
+	{"HP", NULL, "HPOR"},
+};
+
+#define PMDK_DAI_FMT (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | \
+	SND_SOC_DAIFMT_CBS_CFS)
+
+static struct snd_soc_dai_link pmdk_dai[] = {
+	{
+		.name = "ES8336 HIFI",
+		.stream_name = "ES8336 HIFI",
+		.cpu_dai_name = "phytium-i2s-lsd",
+		.codec_dai_name = "es8336-hifi",
+		.platform_name = "snd-soc-dummy",
+		.codec_name = "i2c-ESSX8336:00",
+		.dai_fmt = PMDK_DAI_FMT,
+	},
+};
+
+static struct snd_soc_card pmdk = {
+	.name = "PMDK-I2S",
+	.owner = THIS_MODULE,
+	.dai_link = pmdk_dai,
+	.num_links = ARRAY_SIZE(pmdk_dai),
+
+	.dapm_widgets = pmdk_es8336_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(pmdk_es8336_dapm_widgets),
+	.controls = pmdk_controls,
+	.num_controls = ARRAY_SIZE(pmdk_controls),
+	.dapm_routes = pmdk_es8336_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(pmdk_es8336_audio_map),
+};
+
+static int pmdk_sound_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &pmdk;
+	struct device *dev = &pdev->dev;
+	card->dev = dev;
+	return devm_snd_soc_register_card(&pdev->dev, card);
+}
+
+static const struct acpi_device_id pmdk_sound_acpi_match[] = {
+	{ "PHYT8005", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, pmdk_sound_acpi_match);
+
+static struct platform_driver pmdk_sound_driver = {
+	.probe = pmdk_sound_probe,
+	.driver = {
+		.name = "pmdk_es8336",
+		.acpi_match_table = pmdk_sound_acpi_match,
+#ifdef CONFIG_PM
+		.pm = &snd_soc_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(pmdk_sound_driver);
+MODULE_AUTHOR("Zhang Yiqun <zhangyiqun@phytium.com.cn>");
+MODULE_DESCRIPTION("ALSA SoC PMDK ES8336");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/phytium/pmdk_es8388.c b/sound/soc/phytium/pmdk_es8388.c
new file mode 100644
index 000000000000..194a4dca7ea8
--- /dev/null
+++ b/sound/soc/phytium/pmdk_es8388.c
@@ -0,0 +1,174 @@
+/*
+ *  pmdk_es8388.c
+ *
+ *  Copyright (c) 2021 Phytium Techonology Co. Ltd
+ *  Author: Zhang Yiqun <zhangyiqun@phytium.com.cn>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/jack.h>
+
+static struct snd_soc_jack hs_jack;
+
+/* Headset jack detection DAPM pins */
+static struct snd_soc_jack_pin hs_jack_pins[] = {
+	{
+		.pin	= "FrontIn",
+		.mask	= SND_JACK_MICROPHONE,
+	},
+	{
+		.pin	= "RearIn",
+		.mask	= SND_JACK_MICROPHONE,
+		.invert = 1
+	},
+	{
+		.pin	= "Front",
+		.mask	= SND_JACK_HEADPHONE,
+	},
+	{
+		.pin    = "Rear",
+		.mask   = SND_JACK_HEADPHONE,
+		.invert = 1
+	},
+};
+
+/* Headset jack detection gpios */
+static struct snd_soc_jack_gpio hs_jack_gpios[] = {
+	{
+		.name		= "det",
+		.report		= SND_JACK_HEADSET,
+		.debounce_time	= 200,
+		.invert		= 1,
+	},
+};
+
+/* PMDK widgets */
+static const struct snd_soc_dapm_widget pmdk_es8388_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Front", NULL),
+	SND_SOC_DAPM_HP("Rear", NULL),
+
+	SND_SOC_DAPM_MIC("FrontIn", NULL),
+	SND_SOC_DAPM_MIC("RearIn", NULL),
+};
+
+/* PMDK control */
+static const struct snd_kcontrol_new pmdk_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Front"),
+	SOC_DAPM_PIN_SWITCH("Rear"),
+	SOC_DAPM_PIN_SWITCH("FrontIn"),
+	SOC_DAPM_PIN_SWITCH("RearIn"),
+};
+
+/* PMDK connections */
+static const struct snd_soc_dapm_route pmdk_es8388_audio_map[] = {
+	{"LINPUT1", NULL, "FrontIn"},
+	{"RINPUT1", NULL, "FrontIn"},
+
+	{"LINPUT2", NULL, "RearIn"},
+	{"RINPUT2", NULL, "RearIn"},
+
+	{"Front", NULL, "LOUT1"},
+	{"Front", NULL, "ROUT1"},
+
+	{"Rear", NULL, "LOUT2"},
+	{"Rear", NULL, "ROUT2"},
+};
+
+static int pmdk_es8388_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret;
+
+	/* Jack detection API stuff */
+	ret = snd_soc_card_jack_new(rtd->card, "Headset Jack", SND_JACK_HEADSET,
+				    &hs_jack, hs_jack_pins,
+				    ARRAY_SIZE(hs_jack_pins));
+	if (ret)
+		goto err;
+
+	ret = snd_soc_jack_add_gpios(&hs_jack, ARRAY_SIZE(hs_jack_gpios),
+				hs_jack_gpios);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	return ret;
+}
+
+#define PMDK_DAI_FMT (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | \
+	SND_SOC_DAIFMT_CBS_CFS)
+
+static struct snd_soc_dai_link pmdk_dai[] = {
+	{
+		.name = "ES8388 HIFI",
+		.stream_name = "ES8388 HIFI",
+		.cpu_dai_name = "phytium-i2s-lsd",
+		.codec_dai_name = "es8388-hifi",
+		.platform_name = "snd-soc-dummy",
+		.codec_name = "i2c-ESSX8388:00",
+		.dai_fmt = PMDK_DAI_FMT,
+		.init = pmdk_es8388_init,
+	},
+};
+
+static struct snd_soc_card pmdk = {
+	.name = "PMDK-I2S",
+	.owner = THIS_MODULE,
+	.dai_link = pmdk_dai,
+	.num_links = ARRAY_SIZE(pmdk_dai),
+
+	.dapm_widgets = pmdk_es8388_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(pmdk_es8388_dapm_widgets),
+	.controls = pmdk_controls,
+	.num_controls = ARRAY_SIZE(pmdk_controls),
+	.dapm_routes = pmdk_es8388_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(pmdk_es8388_audio_map),
+};
+
+static int pmdk_sound_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &pmdk;
+	struct device *dev = &pdev->dev;
+	int n;
+
+	card->dev = dev;
+	hs_jack_gpios[0].gpiod_dev = dev;
+	n = gpiod_count(dev, "det");
+
+	if(n < 0)
+		pmdk_dai[0].init = NULL;
+
+	return devm_snd_soc_register_card(&pdev->dev, card);
+}
+
+static const struct acpi_device_id pmdk_sound_acpi_match[] = {
+	{ "PHYT8004", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, pmdk_sound_acpi_match);
+
+static struct platform_driver pmdk_sound_driver = {
+	.probe = pmdk_sound_probe,
+	.driver = {
+		.name = "pmdk_es8388",
+		.acpi_match_table = pmdk_sound_acpi_match,
+#ifdef CONFIG_PM
+		.pm = &snd_soc_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(pmdk_sound_driver);
+
+MODULE_AUTHOR("Zhang Yiqun<zhangyiqun@phytium.com.cn>");
+MODULE_DESCRIPTION("ALSA SoC PMDK ES8388");
+MODULE_LICENSE("GPL");
-- 
Armbian

