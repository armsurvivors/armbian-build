From bc7d9575a0c10077397e69fe37587930abf471e9 Mon Sep 17 00:00:00 2001
From: AngeloGioacchino Del Regno <angelogioacchino.delregno@somainline.org>
Date: Wed, 11 Aug 2021 21:28:34 +0200
Subject: [PATCH 065/127] adreno 5xx: TTBR1 extravaganza on MSM8998

(JAMI: fixup for 5.16)
---
 .../msm8998-sony-xperia-yoshino-maple.dts     |  4 +-
 drivers/gpu/drm/msm/adreno/a5xx_gpu.c         | 66 ++++++++++++++++++-
 drivers/gpu/drm/msm/adreno/a5xx_gpu.h         |  1 +
 drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c    |  4 +-
 4 files changed, 69 insertions(+), 6 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/msm8998-sony-xperia-yoshino-maple.dts b/arch/arm64/boot/dts/qcom/msm8998-sony-xperia-yoshino-maple.dts
index 78502477ab56..92654b1e4f6b 100644
--- a/arch/arm64/boot/dts/qcom/msm8998-sony-xperia-yoshino-maple.dts
+++ b/arch/arm64/boot/dts/qcom/msm8998-sony-xperia-yoshino-maple.dts
@@ -107,8 +107,8 @@ &pmi8998_wled {
 	status = "okay";
 
 	//qcom,auto-string-detection;
-	qcom,num-strings = <4>;
-	qcom,enabled-strings = <0 1 2 3>;
+	qcom,num-strings = <3>;
+	qcom,enabled-strings = <0 1 2>;
 };
 
 &wcd9335 {
diff --git a/drivers/gpu/drm/msm/adreno/a5xx_gpu.c b/drivers/gpu/drm/msm/adreno/a5xx_gpu.c
index 3dcec7acb384..7ba1afef3412 100644
--- a/drivers/gpu/drm/msm/adreno/a5xx_gpu.c
+++ b/drivers/gpu/drm/msm/adreno/a5xx_gpu.c
@@ -121,6 +121,48 @@ static void a5xx_submit_in_rb(struct msm_gpu *gpu, struct msm_gem_submit *submit
 	msm_gpu_retire(gpu);
 }
 
+static void a5xx_set_pagetable(struct a5xx_gpu *a5xx_gpu,
+		struct msm_ringbuffer *ring, struct msm_file_private *ctx)
+{
+	phys_addr_t ttbr;
+	u32 asid;
+	u64 memptr = rbmemptr(ring, ttbr0);
+
+	if (ctx == a5xx_gpu->cur_ctx)
+		return;
+
+	if (msm_iommu_pagetable_params(ctx->aspace->mmu, &ttbr, &asid))
+		return;
+
+	/* Execute the table update */
+	OUT_PKT7(ring, CP_SMMU_TABLE_UPDATE, 3);
+	OUT_RING(ring, CP_SMMU_TABLE_UPDATE_0_TTBR0_LO(lower_32_bits(ttbr)));
+
+	OUT_RING(ring,
+		CP_SMMU_TABLE_UPDATE_1_TTBR0_HI(upper_32_bits(ttbr)) |
+		CP_SMMU_TABLE_UPDATE_1_ASID(asid));
+	OUT_RING(ring, CP_SMMU_TABLE_UPDATE_2_CONTEXTIDR(0));
+
+	/*
+	 * Write the new TTBR0 to the memstore. This is good for debugging.
+	 */
+	OUT_PKT7(ring, CP_MEM_WRITE, 4);
+	OUT_RING(ring, CP_MEM_WRITE_0_ADDR_LO(lower_32_bits(memptr)));
+	OUT_RING(ring, CP_MEM_WRITE_1_ADDR_HI(upper_32_bits(memptr)));
+	OUT_RING(ring, lower_32_bits(ttbr));
+	OUT_RING(ring, (asid << 16) | upper_32_bits(ttbr));
+
+	/*
+	 * And finally, trigger a uche flush to be sure there isn't anything
+	 * lingering in that part of the GPU
+	 */
+
+	OUT_PKT7(ring, CP_EVENT_WRITE, 1);
+	OUT_RING(ring, 0x31);
+
+	a5xx_gpu->cur_ctx = ctx;
+}
+
 static void a5xx_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit)
 {
 	struct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);
@@ -151,13 +193,17 @@ static void a5xx_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit)
 	OUT_RING(ring, 1);
 
 	/* Enable local preemption for finegrain preemption */
-	OUT_PKT7(ring, CP_PREEMPT_ENABLE_GLOBAL, 1);
-	OUT_RING(ring, 0x02);
+	//OUT_PKT7(ring, CP_PREEMPT_ENABLE_GLOBAL, 1);
+	//OUT_RING(ring, 0x02);
+	OUT_PKT7(ring, CP_PREEMPT_ENABLE_LOCAL, 1);
+	OUT_RING(ring, 0x01);
 
 	/* Allow CP_CONTEXT_SWITCH_YIELD packets in the IB2 */
 	OUT_PKT7(ring, CP_YIELD_ENABLE, 1);
 	OUT_RING(ring, 0x02);
 
+	a5xx_set_pagetable(a5xx_gpu, ring, submit->queue->ctx);
+
 	/* Submit the commands */
 	for (i = 0; i < submit->nr_cmds; i++) {
 		switch (submit->cmd[i].type) {
@@ -942,6 +988,7 @@ static int a5xx_hw_init(struct msm_gpu *gpu)
 		a5xx_preempt_fini(gpu);
 		gpu->nr_rings = 1;
 	}
+	a5xx_gpu->cur_ctx = NULL;
 
 	a5xx_preempt_hw_init(gpu);
 
@@ -1684,6 +1731,20 @@ static uint32_t a5xx_get_rptr(struct msm_gpu *gpu, struct msm_ringbuffer *ring)
 	return ring->memptrs->rptr = gpu_read(gpu, REG_A5XX_CP_RB_RPTR);
 }
 
+static struct msm_gem_address_space *
+a5xx_create_private_address_space(struct msm_gpu *gpu)
+{
+	struct msm_mmu *mmu;
+
+	mmu = msm_iommu_pagetable_create(gpu->aspace->mmu);
+
+	if (IS_ERR(mmu))
+		return ERR_CAST(mmu);
+
+	return msm_gem_address_space_create(mmu,
+		"gpu", 0x100000000ULL, 0x1ffffffffULL);
+}
+
 static const struct adreno_gpu_funcs funcs = {
 	.base = {
 		.get_param = adreno_get_param,
@@ -1706,6 +1767,7 @@ static const struct adreno_gpu_funcs funcs = {
 		.gpu_state_get = a5xx_gpu_state_get,
 		.gpu_state_put = a5xx_gpu_state_put,
 		.create_address_space = adreno_iommu_create_address_space,
+		.create_private_address_space = a5xx_create_private_address_space,
 		.get_rptr = a5xx_get_rptr,
 	},
 	.get_timestamp = a5xx_get_timestamp,
diff --git a/drivers/gpu/drm/msm/adreno/a5xx_gpu.h b/drivers/gpu/drm/msm/adreno/a5xx_gpu.h
index c7187bcc5e90..781b759918e9 100644
--- a/drivers/gpu/drm/msm/adreno/a5xx_gpu.h
+++ b/drivers/gpu/drm/msm/adreno/a5xx_gpu.h
@@ -29,6 +29,7 @@ struct a5xx_gpu {
 
 	struct msm_ringbuffer *cur_ring;
 	struct msm_ringbuffer *next_ring;
+	struct msm_file_private *cur_ctx;
 
 	struct drm_gem_object *preempt_bo[MSM_GPU_MAX_RINGS];
 	struct drm_gem_object *preempt_counters_bo[MSM_GPU_MAX_RINGS];
diff --git a/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c b/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c
index 03e016058ee5..e9e69672d189 100644
--- a/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c
+++ b/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c
@@ -197,13 +197,13 @@ static int qcom_adreno_smmu_alloc_context_bank(struct arm_smmu_domain *smmu_doma
 
 static bool qcom_adreno_can_do_ttbr1(struct arm_smmu_device *smmu)
 {
+/*
 	const struct device_node *np = smmu->dev->of_node;
-
 	if (of_device_is_compatible(np, "qcom,msm8996-smmu-v2") ||
 	    of_device_is_compatible(np, "qcom,msm8998-smmu-v2") ||
 	    of_device_is_compatible(np, "qcom,sdm630-smmu-v2"))
 		return false;
-
+*/
 	return true;
 }
 
-- 
2.38.1

